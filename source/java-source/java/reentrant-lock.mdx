---
title: AQS å’Œ ReentrantLock
date: 2023-03-08 12:37:15
categories:
  - Javaæºç 
seo:
  description: ReentrantLock å’Œ AQS æºç è¯¦è§£
---

> [!NOTE]
>  æºç åŸºäº Java 17 (Spring5 éƒ½åœæ­¢ç»´æŠ¤äº†ï¼Œæ˜¯æ—¶å€™å‡çº§äº†...).


åœ¨çœ‹å…·ä½“çœ‹åœ¨è¿™ä¹‹å‰æœ‰ä¸ªé—®é¢˜ï¼šè¯·è¯´è¯´ä½ å¯¹ `AQS` çš„ç†è§£ï¼Ÿ

é¢è¯•çš„æ—¶å€™è¢«é—®åˆ°è¿™ç§é—®é¢˜å°±å¾ˆè›‹ç–¼ï¼Œå› ä¸ºä½ å¯èƒ½çŸ¥é“å®ƒçš„åŸç†ï¼Œä½†æ˜¯ä¸çŸ¥é“æ€ä¹ˆæ¦‚æ‹¬å‡ºæ¥ã€‚

æ‰€ä»¥ä¸ªäººå»ºè®®åœ¨çœ‹æºç å‰ä¸€å®šè¦çœ‹ä¸€ä¸‹æ¯ä¸ªç±»ä¸Šçš„æ³¨é‡Šï¼Œæ¯”å¦‚è¯´è¿™é‡Œçš„ `AQS` (è¿™é‡Œåªæˆªå–äº†éƒ¨åˆ†):

> Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. 
>
> æä¾›äº†ä¸€ä¸ªæ¡†æ¶ï¼Œå»å¸®åŠ©å¼€å‘è€…å®ç°ä¸€ä¸ªä¾èµ–äºå…ˆè¿›å…ˆå‡º(FIFO)ç­‰å¾…é˜Ÿåˆ—çš„åŒæ­¥é”æˆ–ç›¸å…³åŒæ­¥å™¨(äº‹ä»¶ã€ä¿¡å·é‡ç­‰)

å¦‚æœè°ˆç†è§£çš„è¯ï¼Œç”¨è¿™ä¸€å¥å¼€å¤´å°±ä¼šå¾ˆèˆ’æœã€

# æ¦‚è¦

![ç±»ç»§æ‰¿å›¾](https://selfb.asia/public/java-source/2023-2-3-12046ac9-cd7f-4b31-9c43-6f398f6a86a3.webp)

å¯¹äº`ReentrantLock`ï¼Œä½ éœ€è¦çŸ¥é“å®ƒé‡Œé¢æœ‰ä¸€ä¸ª<span classname="text-error">ç­‰å¾…é˜Ÿåˆ—ï¼Œä¹Ÿå°±æ˜¯ AQS </span>(`AbstractQueuedSynchronizer`)ï¼Œ<span classname="text-error">è¿™ä¸ªé˜Ÿåˆ—åªæœ‰â€œå¤´éƒ¨çš„èŠ‚ç‚¹â€æ‰æœ‰èµ„æ ¼æŠ¢åˆ°é”ï¼ä½†è¿™å¹¶ä¸ä»£è¡¨å…¶å®ƒèŠ‚ç‚¹å¯¹åº”çš„çº¿ç¨‹ä¸ä¼šè¢«å”¤é†’ï¼Œè¿™äº›çº¿ç¨‹åªæ˜¯æ²¡æœ‰æŠ¢é”çš„èµ„æ ¼ï¼Œåœ¨è·å–èµ„æ ¼å‰æŠ¢é”æ°¸è¿œå¤±è´¥ã€‚åœ¨è¿™é‡Œéœ€è¦æ³¨æ„ï¼š**æ²¡æœ‰èµ„æ ¼æŠ¢é” != æ²¡æœ‰æœºä¼šè¢«å”¤é†’**ã€‚</span>

![AQSç¤ºä¾‹](https://selfb.asia/images/2024/09/AQS2.webp)

ä¾‹å¦‚ä¸Šå›¾ï¼Œæ˜¯ AQS çš„ä¸€ä¸ªç®€å•ç¤ºä¾‹ã€‚`state` è¡¨ç¤ºé˜Ÿåˆ—çŠ¶æ€ï¼Œå¦‚æœè¯¥å€¼é 0ï¼Œåˆ™è¡¨ç¤ºé”å·²ç»è¢«å…¶å®ƒçº¿ç¨‹å ç”¨ã€‚è¿™é‡Œ `Node0` ç›®å‰å·²ç»æ˜¯æŠ¢åˆ°é”çš„çŠ¶æ€ï¼Œå…¶ä½™èŠ‚ç‚¹éƒ½å¤„äºç­‰å¾…(æŒ‚èµ·)çŠ¶æ€ã€‚

å½“ `Node0` é‡Šæ”¾é”æ—¶ï¼Œå®ƒå°†ä¼šå”¤é†’ `Node1#waiter` å¯¹åº”çš„çº¿ç¨‹ï¼Œå¹¶å»é™¤æ‰ `WAITING` çš„ `status`ï¼Œæ­¤æ—¶ `Node1` å‘ç°è‡ªå·±å¤„äº*ç¬¬ä¸€ä¸ª*ï¼Œå°±ä¼šå°è¯•æŠ¢é”ã€‚å¦‚æœæˆåŠŸï¼Œåˆ™å°† `head` æŒ‡å‘ä¸ºè‡ªå·±ã€‚

> [!NOTE]
> ç¬¬ä¸€ä¸ªï¼šå½“ `node.prev == head` æ—¶ï¼Œå½“å‰èŠ‚ç‚¹å°±æ˜¯ç¬¬ä¸€ä¸ªã€‚

å¯¹äº `Node2`ï¼Œç”±äºå®ƒä¸æ˜¯*ç¬¬ä¸€ä¸ª*èŠ‚ç‚¹ï¼Œæ‰€ä»¥å®ƒä¼šåœ¨æŠ¢é”æ—¶ç›´æ¥è¿›å…¥ `WAITING` çŠ¶æ€ã€‚

## CHL

å…¶å®[æ–‡æ¡£](https://github.com/openjdk/jdk/blob/dfacda488bfbe2e11e8d607a6d08527710286982/src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java#L316-L446)å·²ç»å¾ˆæ¸…æ™°çš„è¯´æ˜äº† AQS æ˜¯æ€ä¹ˆå®ç°çš„äº†ï¼Œå¦‚æœæœ‰èƒ½åŠ›ï¼Œå¯ä»¥ç›´æ¥ç¡¬å•ƒæ–‡æ¡£ã€‚å› ä¸ºå­—æ•°è¿‡å¤šï¼Œè¿™é‡Œæˆ‘åªæ‘˜å‡ºä¸€éƒ¨åˆ†ã€‚

---

CLH å¯ä»¥é¿å…ä½¿ç”¨åŒæ­¥é”ï¼Œé€šè¿‡ `prev` å’Œ `next` å¯¹å‰åèŠ‚ç‚¹çš„è¿æ¥ä»¥åŠ `status` å­—æ®µï¼Œå½“çº¿ç¨‹é‡Šæ”¾é”æ—¶ï¼ŒCLH é˜Ÿåˆ—å¯ä»¥ç»™å®ƒçš„ç»§ä»»è€…å‘é€ä¸€ä¸ªä¿¡å·ï¼Œæ­¤æ—¶ç»§ä»»è€…å¯ä»¥è¿›ä¸€æ­¥è¿›è¡ŒæŠ¢é”æ“ä½œã€‚

```text
 +------+  prev +-------+       +------+
 | head | <---- | first | <---- | tail |
 +------+       +-------+       +------+
```

å‘ CLH æ’å…¥èŠ‚ç‚¹åªéœ€è¦åœ¨ `tail` æ‰§è¡Œä¸€ä¸ªåŸå­æ“ä½œã€‚å½“ CAS æ“ä½œæ‰§è¡ŒæˆåŠŸåï¼Œåªéœ€è¦å†å°†ä¹‹å‰çš„ `tail.next` è®¾ç½®ä¸ºè‡ªå·±å³å¯ã€‚å³ä½¿åé¢åé¢è¿™ä¸€æ­¥ä¸æ˜¯åŸå­æ“ä½œï¼Œ
ä½†æ˜¯ä¹Ÿè¶³å¤Ÿç¡®ä¿ä»»ä½•è¢«é˜»å¡çš„çº¿ç¨‹ï¼Œéƒ½èƒ½å¤ŸæˆåŠŸçš„æ¥æ”¶åˆ°å‰ä»»è€…çš„ä¿¡å·(ä¾‹å¦‚ `Node0` æ˜¯å½“å‰çš„ `tail`ï¼Œæ­¤æ—¶ CAS æ’å…¥ `Node1` çš„åŒæ—¶ `Node0` çš„é”é‡Šæ”¾æ‰äº†ï¼Œæ­¤æ—¶ `Node0.next` ä¸ºç©ºï¼Œä½†æ˜¯ä»ç„¶ä¸å½±å“ä»£ç çš„æ­£å¸¸è¿è¡Œ)ã€‚


# æºç 

## 1.1 æ„é€ å™¨

```java
/**
 * Creates an instance of {@code ReentrantLock}.
 * This is equivalent to using {@code ReentrantLock(false)}.
 */
public ReentrantLock() {
  sync = new NonfairSync();
}

/**
 * Creates an instance of {@code ReentrantLock} with the
 * given fairness policy.
 *
 * @param fair {@code true} if this lock should use a fair ordering policy
 */
public ReentrantLock(boolean fair) {
  sync = fair ? new FairSync() : new NonfairSync();
}
```

å¯ä»¥é€šè¿‡æ„é€ å™¨æ¥è®¾ç½®é”æ˜¯å¦ä¸ºå…¬å¹³é”ï¼Œé»˜è®¤ä¸ºéå…¬å¹³é”

å…¬å¹³é”å’Œéå…¬å¹³é”çš„å”¯ä¸€åŒºåˆ«å°±æ˜¯å…¬å¹³é”å¤šäº†ä¸€ä¸ªåˆ¤æ–­æ¡ä»¶ï¼š`hasQueuedPredecessors`ã€‚è¯¥æ–¹æ³•ä¸»è¦ç”¨äºåˆ¤æ–­å…¬å¹³é”åŠ é”æ—¶ç­‰å¾…é˜Ÿåˆ—ä¸­æ˜¯å¦å­˜åœ¨æœ‰æ•ˆèŠ‚ç‚¹ã€‚

```java
// å…¬å¹³é”
@ReservedStackAccess
protected final boolean tryAcquire(int acquires) {
  final Thread current = Thread.currentThread();
  int c = getState();
  if (c == 0) {
    // å…¬å¹³åªæ¯”éå…¬å¹³é”å¤šäº†ä¸‹é¢ä¸€ä¸ªæ¡ä»¶ï¼Œå…¶ä½™å’Œéå…¬å¹³é”ä¸€æ ·ã€‚
    // è¿™é‡Œä¼šåˆ¤æ–­é˜Ÿåˆ—ä¸­æ˜¯å¦æœ‰æ­£åœ¨æ’é˜Ÿçš„çº¿ç¨‹ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™ç›´æ¥æŠ¢é”ï¼Œä¸è¿›é˜Ÿåˆ—äº†
    if (!hasQueuedPredecessors() &&
      compareAndSetState(0, acquires)) {
      setExclusiveOwnerThread(current);
      return true;
    }
  }
  else if (current == getExclusiveOwnerThread()) {
    int nextc = c + acquires;
    if (nextc < 0)
      throw new Error("Maximum lock count exceeded");
    setState(nextc);
    return true;
  }
  return false;
}
```

è¿™é‡Œå¯ä»¥å‘ç°ï¼Œå¦‚æœæ˜¯éå…¬å¹³é”ï¼Œçº¿ç¨‹åœ¨å…¥é˜Ÿä¹‹å‰æ€»ä¼šå°è¯•æŠ¢é”ï¼Œå¦‚æœæŠ¢åˆ°äº†å°±ä¸ä¼šå…¥é˜Ÿäº†ã€‚å¦‚æœæ˜¯å…¬å¹³é”å…¥é˜Ÿå‰ï¼Œåªä¼šåœ¨ç­‰å¾…é˜Ÿåˆ—ä¸ºç©ºæ—¶å°è¯•æŠ¢é”ï¼Œå¦åˆ™éœ€è¦è€è€å®å®å…¥é˜Ÿã€‚

> [!IMPORTANT]
> è¿™é‡Œä»¥éå…¬å¹³é”ä¸ºä¾‹æ¼”ç¤ºï¼Œå½“ä»£ç ä¸ä¸€æ ·æ—¶ä¼šå•ç‹¬æŒ‡å‡ºï¼Œå¦åˆ™è¡¨ç¤ºä¸¤è¾¹å®ç°ä¸€æ ·ã€‚

## 1.2 lock

`lock`æ–¹æ³•ä¸»è¦è°ƒç”¨äº†AQSä¸­çš„`acquire`æ–¹æ³•

```java
// è¯¥æ–¹æ³•æ˜¯RentrantLocké‡Œçš„
final void lock() {
  if (!initialTryLock())
    acquire(1);
}

// éå…¬å¹³é”
final boolean initialTryLock() {
  Thread current = Thread.currentThread();
  if (compareAndSetState(0, 1)) { // first attempt is unguarded
    setExclusiveOwnerThread(current);
    return true;
  } else if (getExclusiveOwnerThread() == current) {
    int c = getState() + 1;
    if (c < 0) // overflow
      throw new Error("Maximum lock count exceeded");
    setState(c);
    return true;
  } else
    return false;
}

// å…¬å¹³é”
final boolean initialTryLock() {
  Thread current = Thread.currentThread();
  int c = getState();
  if (c == 0) {
    if (!hasQueuedThreads() && compareAndSetState(0, 1)) {
      setExclusiveOwnerThread(current);
      return true;
    }
  } else if (getExclusiveOwnerThread() == current) {
    if (++c < 0) // overflow
      throw new Error("Maximum lock count exceeded");
    setState(c);
    return true;
  }
  return false;
}

// è¯¥æ–¹æ³•æ˜¯AQSç±»é‡Œçš„
public final void acquire(int arg) {
  if (!tryAcquire(arg))
    acquire(null, arg, false, false, false, 0L);
}
```

> [!IMPORTANT]
> å¯ä»¥å‘ç°å…¬å¹³é”å’Œéå…¬å¹³é”çš„å”¯ä¸€åŒºåˆ«å°±æ˜¯ï¼šå…¬å¹³é”åœ¨æ²¡å…¥é˜Ÿå‰æŠ¢é”æ€»æ˜¯éœ€è¦åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºã€‚
>
> è¿™é‡Œåé¢å°±åªå±•ç¤º**éå…¬å¹³é”**çš„ä»£ç äº†ã€‚

å¤§è‡´æµç¨‹æµç¨‹:

<PintoraDiagram code={`
activityDiagram
title: lock æµç¨‹
start
if(é”ç©ºé—²å¹¶ä¸”æŠ¢é”æˆåŠŸ)then
  :æŠ¢é”æˆåŠŸ;
  end
else(no)
  :ç»§ç»­æŠ¢é”;
endif
if (å½“å‰çº¿ç¨‹æ˜¯å¦ä¸ºå·²ç»æŒæœ‰é”çš„çº¿ç¨‹)then
  :state + 1 æ ‡è®°é‡å…¥ 1 æ¬¡;
  :æŠ¢é”æˆåŠŸ;
  end
else(no)
endif
:å°è¯•è¿›å…¥ç­‰å¾…é˜Ÿåˆ—ç»§ç»­æŠ¢é”;
end
`}/>


### 1.2.1 tryAcquire

AQS ä½¿ç”¨äº†æ¨¡æ¿æ¨¡å¼ï¼Œè¿™é‡Œ `tryAcquire` æ˜¯ä¸€ä¸ªæ¨¡æ¿æ–¹æ³•ï¼Œéœ€è¦å­ç±»å®ç°ã€‚è¯¥æ–¹æ³•ä¼šå…ˆå°è¯•æŠ¢å é” (å°è¯•å°† `status` ä» `0` è®¾ç½®ä¸º`1` )ï¼Œè‹¥å¤±è´¥åˆ™ç»§ç»­åˆ¤æ–­:

```java
protected final boolean tryAcquire(int acquires) {
  if (getState() == 0 && compareAndSetState(0, acquires)) {
    setExclusiveOwnerThread(Thread.currentThread());
    return true;
  }
  return false;
}
```

### 1.2.2 acquire

å¦‚æœ`tryAcquire`æ²¡æœ‰æ‹¿åˆ°é”ï¼Œåˆ™ä¼šè¿›å…¥è¿™ä¸€æ­¥ï¼šå°†çº¿ç¨‹åŠ å…¥åˆ°ç­‰å¾…é˜Ÿåˆ—ã€‚ä»£ç å¾ˆé•¿ï¼š

```java
final int acquire(Node node, int arg, boolean shared,
                    boolean interruptible, boolean timed, long time) {
  Thread current = Thread.currentThread();
  byte spins = 0, postSpins = 0;   // retries upon unpark of first thread
  boolean interrupted = false, first = false;
  Node pred = null;                // predecessor of node when enqueued

  /*
      * Repeatedly:
      *  Check if node now first
      *    if so, ensure head stable, else ensure valid predecessor
      *  if node is first or not yet enqueued, try acquiring
      *  else if node not yet created, create it
      *  else if not yet enqueued, try once to enqueue
      *  else if woken from park, retry (up to postSpins times)
      *  else if WAITING status not set, set and retry
      *  else park and clear WAITING status, and check cancellation
      */
  for (;;) {
    if (!first && (pred = (node == null) ? null : node.prev) != null &&
      !(first = (head == pred))) {
      if (pred.status < 0) {
        cleanQueue();           // predecessor cancelled
        continue;
      } else if (pred.prev == null) {
        Thread.onSpinWait();    // ensure serialization
        continue;
      }
    }
    if (first || pred == null) { // ä¸ºç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæˆ–è€…è¿˜æ²¡æœ‰å…¥é˜Ÿï¼Œç›´æ¥å°è¯•æŠ¢é”
      boolean acquired;
      try {
        if (shared)
          acquired = (tryAcquireShared(arg) >= 0);
        else
          acquired = tryAcquire(arg);
      } catch (Throwable ex) {
        cancelAcquire(node, interrupted, false);
        throw ex;
      }
      if (acquired) {
        if (first) { // å°†è‡ªå·±è®¾ç½®ä¸ºç¬¬ä¸€ä¸ªèŠ‚ç‚¹
          node.prev = null;
          head = node;
          pred.next = null;
          node.waiter = null;
          if (shared)
              signalNextIfShared(node);
          if (interrupted)
              current.interrupt();
        }
        return 1;
      }
    }
    if (node == null) {                 // åˆ›å»ºèŠ‚ç‚¹å¹¶é‡æ–°å¾ªç¯
      if (shared)
        node = new SharedNode();
      else
        node = new ExclusiveNode();
    } else if (pred == null) {          // å°è¯•å°†èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—(å°¾æ’)
      node.waiter = current;
      Node t = tail;
      node.setPrevRelaxed(t);         // è¿™é‡Œä½¿ç”¨ unsafe èµ‹å€¼ï¼Œé¿å…äº†è¯»å†™å±éšœå¯¼è‡´æ•°æ®ä¸ä¸€è‡´
      if (t == null)
        tryInitializeHead();
      else if (!casTail(t, node))     // å°è¯• CAS è®¾ç½®å°¾ç»“ç‚¹
        node.setPrevRelaxed(null);  // back out
      else
        t.next = node;
    } else if (first && spins != 0) {
      --spins;                        // reduce unfairness on rewaits, è¿™é‡Œåé¢è¯´
      Thread.onSpinWait();            // æŒ‡ç¤ºå½“å‰çº¿ç¨‹æš‚æ—¶æ— æ³•åœ¨å¾ªç¯ä¸­å®Œæˆä»»åŠ¡ï¼ŒJVMä¼šä¼˜åŒ–æ­¤ç±»å¾ªç¯ä»¥æé«˜æ€§èƒ½
    } else if (node.status == 0) {      // çŠ¶æ€ä¸º 0 è¡¨ç¤ºæ­£åœ¨æŠ¢é”
      node.status = WAITING;          // è®¾ç½®èŠ‚ç‚¹çŠ¶æ€ä¸ºç­‰å¾…
    } else {
      long nanos; // æŒ‚èµ·çº¿ç¨‹ï¼Œç­‰å¾…ä¸‹æ¬¡å”¤é†’
      spins = postSpins = (byte)((postSpins << 1) | 1); // è¿™é‡Œåé¢è¯´
      if (!timed)
        LockSupport.park(this);
      else if ((nanos = time - System.nanoTime()) > 0L)
        LockSupport.parkNanos(this, nanos);
      else
        break;
      node.clearStatus();
      if ((interrupted |= Thread.interrupted()) && interruptible)
        break;
    }
  }
  return cancelAcquire(node, interrupted, interruptible);
}
```

è¿™é‡Œåœ¨æ³¨é‡Šé‡Œå·²ç»è®²çš„å¾ˆæ¸…æ¥šäº†ï¼Œä¸»è¦å¹²äº†è¿™ä¹ˆå‡ ä»¶äº‹ï¼š

1. if æ˜¯ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç¡®ä¿ç»§ä»»è€…æœ‰æ•ˆ(åˆæ³•)
2. if èŠ‚ç‚¹æ˜¯ç¬¬ä¸€ä¸ªå¹¶ä¸”è¿˜æ²¡æœ‰å…¥é˜Ÿï¼Œåˆ™å°è¯•æŠ¢é”
3. else if èŠ‚ç‚¹æ²¡æœ‰è¢«åˆ›å»ºï¼Œåˆ™åˆ›å»ºå¯¹åº”çš„èŠ‚ç‚¹
4. else if èŠ‚ç‚¹æ²¡æœ‰å…¥é˜Ÿï¼Œåˆ™å°è¯•å…¥é˜Ÿ
5. else if çº¿ç¨‹è¢«å”¤é†’ï¼Œåˆ™é‡æ–°è‡ªæ—‹å¹¶è®¾ç½®æ›´å¤§çš„ `spins` ä»¥é˜²æ­¢ä¸€ç›´æŠ¢ä¸åˆ°é”
6. else if WAITING çŠ¶æ€æ²¡æœ‰è¢«è®¾ç½®ï¼Œåˆ™è®¾ç½®å¹¶è¯¥çŠ¶æ€å¹¶é‡è¯•
7. else æŒ‚èµ·çº¿ç¨‹ï¼Œç„¶åæ¸…é™¤ WAITING çŠ¶æ€å¹¶æ£€æŸ¥å–æ¶ˆ(ä¸­æ–­)è¯·æ±‚

åœ¨ç»§ç»­å‰ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹èŠ‚ç‚¹çš„ `status` æœ‰å“ªäº›:

```java
// è¡¨ç¤ºå½“å‰èŠ‚ç‚¹æ­£åœ¨ç­‰å¾…ä¿¡å·
static final int WAITING   = 1;          // must be 1
// è¡¨ç¤ºå½“å‰èŠ‚ç‚¹å·²ç»è¢«å–æ¶ˆäº†ï¼Œå³æ”¾å¼ƒæŠ¢é”
static final int CANCELLED = 0x80000000; // must be negative. 1000 0000 0000 0000 0000 0000 0000 0001
// è¡¨ç¤ºå½“å‰èŠ‚ç‚¹å·²ç»è¢«æŒ‚èµ·ï¼Œæ­£åœ¨ç­‰å¾…å”¤é†’ä¿¡å·
static final int COND      = 2;          // in a condition wait
```

è¿™é‡Œ `COND` åé¢å†è¯´ï¼Œ`ReentrantLock` é‡Œé¢æ²¡æœ‰ç”¨åˆ°ã€‚`WAITING` åˆ™æ˜¯è¡¨ç¤ºå½“å‰èŠ‚ç‚¹æ­£åœ¨ç­‰å¾…ä¿¡å·ã€‚

### cleanQueue

è¿™é‡Œ[ä»£ç ](https://github.com/openjdk/jdk/blob/dfacda488bfbe2e11e8d607a6d08527710286982/src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java#L733-L761)å¾ˆæ¶å¿ƒï¼Œå˜é‡åç§°å…¨éƒ¨ç”¨ä¸€ä¸ªå­—ç¬¦è¡¨ç¤ºï¼Œè¿™é‡Œæˆ‘æŠŠå®ƒæ¢æˆäº†ç¨å¾®èƒ½ç†è§£çš„åç§°ï¼š

```java
private void cleanQueue() {
  for (;;) {                               // restart point
    for (Node currentNode = tail, nextNode = null, prevNode, prevNext;;) { // (prevNode, currentNode, nextNode) triples
      if (currentNode == null || (prevNode = currentNode.prev) == null)
        return;                      // end of list
      if (nextNode == null ? tail != currentNode : (nextNode.prev != currentNode || nextNode.status < 0))
        break;                       // inconsistent
      if (currentNode.status < 0) {              // cancelled
        if ((nextNode == null ? casTail(currentNode, prevNode) : nextNode.casPrev(currentNode, prevNode)) &&
          currentNode.prev == prevNode) {
          prevNode.casNext(currentNode, nextNode);         // OK if fails
          if (prevNode.prev == null)
            signalNext(prevNode);
        }
        break;
      }
      if ((prevNext = prevNode.next) != currentNode) {         // help finish
        if (prevNext != null && currentNode.prev == prevNode) {
          prevNode.casNext(prevNext, currentNode);
          if (prevNode.prev == null)
            signalNext(prevNode);
        }
        break;
      }
      nextNode = currentNode;
      currentNode = currentNode.prev;
    }
  }
}
```
æœ€åè¿™æ®µ `help finish` å¯èƒ½æœ‰ç‚¹è¿·ï¼Œä¸ºä»€ä¹ˆè¿˜è¦å¸®åˆ«äººå®ŒæˆèŠ‚ç‚¹è¿æ¥ï¼Œè¿™é‡Œæˆ‘ä»¬å¯ä»¥çœ‹ä¸€ä¸‹[å‰é¢çš„ä»£ç ](https://github.com/openjdk/jdk/blob/dfacda488bfbe2e11e8d607a6d08527710286982/src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java#L697-L705)æˆ‘ä»¬æ˜¯æ€ä¹ˆæŠŠèŠ‚ç‚¹æ’å…¥åˆ°é˜Ÿåˆ—ä¸­çš„:

```java
node.waiter = current;
Node t = tail;
node.setPrevRelaxed(t);         // avoid unnecessary fence
if (t == null)
  tryInitializeHead();
else if (!casTail(t, node))
  node.setPrevRelaxed(null);  // back out
else
  t.next = node;
```

å¯ä»¥å‘ç° `casTail(t, node)` å’Œ `t.next = node` å¹¶ä¸æ˜¯ä¸€ä¸ªåŸå­æ“ä½œï¼Œæ‰€ä»¥åœ¨é«˜å¹¶å‘ä¸‹ï¼Œå¯èƒ½å¯¼è‡´ `t.next = node` è¿˜æ²¡è¢«æ‰§è¡Œï¼Œå°±è¢«å…¶å®ƒçº¿ç¨‹è§†ä½œè¿›å…¥é˜Ÿåˆ—äº†ã€‚

> [!NOTE]
> è¯´å®è¯ï¼Œæˆ‘ç›®å‰æ²¡æœ‰æƒ³åˆ°ä¸å¸®å¿™ä¼šå‡ºç°ä»€ä¹ˆé—®é¢˜ğŸ« ...ä½†æ˜¯è‚¯å®šæ˜¯æœ‰ç‚¹éšæ‚£åœ¨è¿™é‡Œçš„ã€‚

### cancelAcquire

è¿™ä¸ªæ–¹æ³•å¾ˆç®€å•ï¼Œç›´æ¥çœ‹å°±èƒ½çœ‹æ‡‚ï¼š

```java
private int cancelAcquire(Node node, boolean interrupted,
                            boolean interruptible) {
  if (node != null) {
    node.waiter = null;
    node.status = CANCELLED;
    if (node.prev != null)
      cleanQueue();
  }
  if (interrupted) {
    if (interruptible)
      return CANCELLED;
    else
      Thread.currentThread().interrupt();
  }
  return 0;
}
```


## 1.3 unlock

```java
// Syncç±»çš„æ–¹æ³•
public void unlock() {
  sync.release(1);
}

// AQSçš„æ–¹æ³•
public final boolean release(int arg) {
  if (tryRelease(arg)) {
    signalNext(head);
    return true;
  }
  return false;
}

// Syncç±»çš„æ–¹æ³•
protected final boolean tryRelease(int releases) {
  int c = getState() - releases;
  if (getExclusiveOwnerThread() != Thread.currentThread())
    throw new IllegalMonitorStateException();
  boolean free = (c == 0);
  if (free)
    setExclusiveOwnerThread(null);
  setState(c);
  return free;
}
```

è§£é”çš„ä»£ç éƒ½å¾ˆç®€å•ï¼Œå› ä¸ºå·²ç»å æœ‰äº†é”ï¼Œæ‰€ä»¥ä¸éœ€è¦è¿‡å¤šåˆ¤æ–­ã€‚

### å¤´èŠ‚ç‚¹çš„é‡Šæ”¾

å…ˆæ¥çœ‹ä¸€ä¸‹ `signalNext`:

```java
private static void signalNext(Node h) {
  Node s;
  if (h != null && (s = h.next) != null && s.status != 0) {
    s.getAndUnsetStatus(WAITING);
    LockSupport.unpark(s.waiter);
  }
}
```

è¿™æ®µä»£ç å¾ˆç®€å•ï¼Œåªæ˜¯å–æ¶ˆäº†ç»§ä»»è€…çš„ `WAITING` çŠ¶æ€å¹¶å”¤é†’å®ƒã€‚

å¯ä»¥å‘ç° AQS çš„ `release` æ–¹æ³•æ²¡æœ‰å¯¹ä»»ä½•èŠ‚ç‚¹è¿›è¡Œåˆ é™¤ï¼Œè¿™é‡Œå°±éå¸¸å·§å¦™çš„åˆ©ç”¨äº†åªæœ‰*ç¬¬ä¸€ä¸ª*èŠ‚ç‚¹æ‰èƒ½æŠ¢é”çš„ç‰¹æ€§æ¥å¯¹èŠ‚ç‚¹è¿›è¡Œäº†åˆ é™¤ã€‚åœ¨åé¢*ç¬¬ä¸€ä¸ª*èŠ‚ç‚¹æŠ¢åˆ°é”åï¼Œå®ƒä¼šå°†è‡ªå·±è®¾ç½®ä¸ºæ–°çš„ `tail`ï¼Œæ—§çš„ `tail` å› æ­¤è¢«ä¸¢å¼ƒï¼Œæœ€åè¢«åƒåœ¾å›æ”¶ã€‚

## 1.5 æ€»ç»“

æœ€åç”¨ä¸€å¼ å›¾æ€»ç»“ä¸€ä¸‹å§ï¼š
<PintoraDiagram code={`
activityDiagram
title: lock
start
:å¼€å§‹æŠ¢é”;
switch(å¼€å§‹æŠ¢é”)
case(CAS lock success)
  :è®¾ç½®ç‹¬å ;
  end
case(å…¶å®ƒ)
case(Already locked)
  :é‡å…¥æ¬¡æ•° + 1;
  end
endswitch
if(å†æ¬¡å°è¯•æŠ¢é”)then
  :è®¾ç½®ç‹¬å ;
  end
else
   :continue;
endif
while(å¾ªç¯æŠ¢é”ï¼Œç›´åˆ°æˆåŠŸæˆ–å–æ¶ˆ)
if(ä¸æ˜¯ç¬¬ä¸€ä¸ªèŠ‚ç‚¹)then
  :cleanQueue;
endif
if(æ˜¯ç¬¬ä¸€ä¸ªèŠ‚ç‚¹)then
  if(å°è¯•æŠ¢é”)then
    :è®¾ç½®ç‹¬å ï¼Œå¹¶å°†é˜Ÿåˆ—å¤´éƒ¨æŒ‡å‘è‡ªå·±;
    end
  else
    :continue;
  endif
endif
if(èŠ‚ç‚¹æœªåˆ›å»º)then
  :åˆ›å»ºèŠ‚ç‚¹;
else
  if(èŠ‚ç‚¹çš„prevä¸ºç©º)then
    :å°è¯•å°†èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—;
  else
    if(æ˜¯ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å¹¶ä¸”è‡ªæ—‹æ¬¡æ•°ä¸ä¸º0)then
      :è‡ªæ—‹æ¬¡æ•°å‡ä¸€, ç»§ç»­å¾ªç¯;
    else
      if(èŠ‚ç‚¹ status == 0)then
        :è®¾ç½®èŠ‚ç‚¹çŠ¶æ€ä¸ºWAITING;
      else
        :æé«˜è‡ªæ—‹æ¬¡æ•°, å¹¶æŒ‚èµ·çº¿ç¨‹;
        -> è¢«å”¤é†’;
        :å°†çŠ¶æ€è®¾ç½®ä¸º0;
      endif
    endif
  endif
endif
endwhile
:æŠ¢é”æˆåŠŸ;
end
`}/>
![æ€»ç»“](https://selfb.asia/public/java-source/2023-2-3-aa7d1ca2-677d-4c91-b6b4-411036b452c2.webp)

# 2. Condition

```java
ReentrantLock reentrantLock = new ReentrantLock();
# newConditionæ˜¯AQSæä¾›çš„æ–¹æ³•
Condition condition = reentrantLock.newCondition();
```

å¯¹äº`Condition`ï¼Œè¿™é‡Œæˆ‘ä»¬æ¥äº†è§£ä¸€ä¸‹ `await` å’Œ `signal` è¿™ä¿©ä¸ªé‡è¦çš„æ–¹æ³•ã€‚ä»æ–¹æ³•åå¤§è‡´å°±å¯ä»¥çŒœå‡ºè¿™ä¿©æ˜¯å¹²ä»€ä¹ˆçš„äº†ï¼Œçº¿ç¨‹é€šè¿‡è°ƒç”¨ `await` å¯ä»¥é˜»å¡è‡ªå·±ï¼Œç„¶åå…¶å®ƒçº¿ç¨‹å¯ä»¥è°ƒç”¨ `signal` å’Œ `signalAll` æ¥å”¤é†’ä¸€ä¸ªæˆ–æ‰€æœ‰è¢«é˜»å¡çš„çº¿ç¨‹ã€‚

```java
public final void await() throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    Node node = addConditionWaiter();
    int savedState = fullyRelease(node);
    int interruptMode = 0;
    while (!isOnSyncQueue(node)) {
        LockSupport.park(this);
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    if (node.nextWaiter != null) // clean up if cancelled
        unlinkCancelledWaiters();
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
}
```

## 2.1 await

### 2.1.2 addConditionWaiter

è¿™ä¸ªæ–¹æ³•ä¼šåœ¨**æ¡ä»¶**é˜Ÿåˆ—(æ¯ä¸€ä¸ª`ConditionObject`éƒ½ä¼šè‡ªå¸¦ä¸€ä¸ªæ¡ä»¶é˜Ÿåˆ—)çš„å°¾éƒ¨æ·»åŠ ä¸€ä¸ªæ–°èŠ‚ç‚¹ï¼Œåœ¨æ·»åŠ å‰ä¼šåˆ¤æ–­æœ€åä¸€ä¸ªèŠ‚ç‚¹æ˜¯å¦å·²ç»å¤±æ•ˆï¼Œè‹¥å¤±æ•ˆåˆ™ä¼šè¿›è¡Œé“¾è¡¨åˆ é™¤æ“ä½œï¼Œä¹‹ååˆ›å»ºæ–°èŠ‚ç‚¹ï¼Œæ·»åŠ åˆ°é“¾è¡¨ã€‚

è°ƒç”¨è¿™ä¸ªæ–¹æ³•æ—¶å¿…é¡»ä¿è¯å½“å‰çº¿ç¨‹æŒæœ‰é”ï¼Œå¦åˆ™ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚

```java
private Node addConditionWaiter() {
    // åœ¨è¿™é‡Œåˆ¤æ–­å½“å‰çº¿ç¨‹æ˜¯å¦å·²ç»æ‹¿åˆ°é”ï¼Œæ²¡æ‹¿åˆ°å°±ç›´æ¥æŠ›å¼‚å¸¸
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    Node t = lastWaiter;
    // If lastWaiter is cancelled, clean out.
    // å¦‚æœæœ€åä¸€ä¸ªèŠ‚ç‚¹çš„çŠ¶æ€ä¸æ˜¯Node.CONDITIONï¼Œåˆ™åˆ é™¤è¿™äº›å·²ç»è¢«å–æ¶ˆçš„èŠ‚ç‚¹
    if (t != null && t.waitStatus != Node.CONDITION) {
        // è¿™ä¸ªæ–¹æ³•ä¼šè¿›è¡Œé“¾è¡¨åˆ é™¤ï¼Œåˆ é™¤çŠ¶æ€ä¸æ˜¯Node.CONDITIONçš„èŠ‚ç‚¹
        unlinkCancelledWaiters();
        t = lastWaiter;
    }
	
    Node node = new Node(Node.CONDITION);

    if (t == null)
        firstWaiter = node;
    else
        t.nextWaiter = node;
    lastWaiter = node;
    return node;
}
```

### 2.1.2 fullyRelease

`fullyRelease`ä¼šé‡Šæ”¾å½“å‰çº¿ç¨‹å ç”¨çš„é”ï¼Œå¦‚æœé‡Šæ”¾å¤±è´¥ï¼Œåˆ™ä¼šåˆ é™¤è¯¥èŠ‚ç‚¹ã€‚

```java
final int fullyRelease(Node node) {
    try {
        // stateä¸€èˆ¬è¡¨ç¤ºé‡å…¥æ¬¡æ•°
        int savedState = getState();
        if (release(savedState))
            return savedState;
        throw new IllegalMonitorStateException();
    } catch (Throwable t) {
        node.waitStatus = Node.CAN CELLED;
        throw t;
    }
}

public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            // è¿™é‡Œåˆ«å¿˜äº†ï¼Œå¤´èŠ‚ç‚¹è¦ä¹ˆæ˜¯æ‹¿åˆ°é”çš„çº¿ç¨‹ï¼Œè¦ä¹ˆæ˜¯å ä½èŠ‚ç‚¹ï¼Œå¤´ç»“ç‚¹çš„ä¸‹ä¸€ä¸ªæ‰æ˜¯èƒ½å¤ŸæŠ¢é”çš„çº¿ç¨‹
            unparkSuccessor(h);
        return true;
    }
    return false;
}
```

### 2.1.3 å°æ€»ç»“

```java
public final void await() throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    // æ·»åŠ ç­‰å¾…èŠ‚ç‚¹
    Node node = addConditionWaiter();
    // é‡Šæ”¾é”
    int savedState = fullyRelease(node);
    int interruptMode = 0;
    // è¿™ä¸ªæ–¹æ³•ä¸»è¦æ˜¯åˆ¤æ–­èŠ‚ç‚¹æ˜¯å¦åœ¨åŒæ­¥é˜Ÿåˆ—é‡Œï¼Œåœ¨åŒæ­¥é˜Ÿåˆ—é‡Œäº†è¯´æ˜æœ‰æœºä¼šæŠ¢é”äº†ï¼Œå°±ä¸ç”¨æ­»å¾ªç¯äº†
    while (!isOnSyncQueue(node)) {
        LockSupport.park(this);
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    // åˆ°è¿™é‡Œè¯´æ˜å·²ç»å¾—åˆ°ä¿¡å·ï¼Œæƒ³è¦é‡æ–°è·å–é”äº†ï¼Œå°±è®©å®ƒå»æŠ¢é”
    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    // æ¸…é™¤å¤šä½™çš„waiter
    if (node.nextWaiter != null) // clean up if cancelled
        unlinkCancelledWaiters();
    if (interruptMode != 0)
        // å¦‚æœä¸­æ–­æ¨¡å¼ä¸ºTHROW_IEï¼Œåˆ™ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œå¦‚æœä¸ºREINTERRUPTï¼Œåˆ™ä¼šè°ƒç”¨çº¿ç¨‹çš„ä¸­æ–­æ–¹æ³•ä»¥ç»´æŒä¸­æ–­çŠ¶æ€
        reportInterruptAfterWait(interruptMode);
}
```

## 2.2 signal

```java
public final void signal() {
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    Node first = firstWaiter;
    if (first != null)
        doSignal(first);
}

private void doSignal(Node first) {
    do {
        if ((firstWaiter = first.nextWaiter) == null)
            lastWaiter = null;
        first.nextWaiter = null;
    } while (!transferForSignal(first) &&
             (first = firstWaiter) != null);
}

// å°†èŠ‚ç‚¹ä»æ¡ä»¶é˜Ÿåˆ—ç§»åŠ¨åˆ°åŒæ­¥é˜Ÿåˆ—
final boolean transferForSignal(Node node) {
    /*
     * If cannot change waitStatus, the node has been cancelled.
     */
    // å°†èŠ‚ç‚¹çŠ¶æ€è®¾ç½®ä¸º0(åˆå§‹åŒ–çŠ¶æ€)
    if (!node.compareAndSetWaitStatus(Node.CONDITION, 0))
        return false;

    /*
     * Splice onto queue and try to set waitStatus of predecessor to
     * indicate that thread is (probably) waiting. If cancelled or
     * attempt to set waitStatus fails, wake up to resync (in which
     * case the waitStatus can be transiently and harmlessly wrong).
     */
    
    Node p = enq(node);
    int ws = p.waitStatus;
    if (ws > 0 || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))
        LockSupport.unpark(node.thread);
    return true;
}

// å°†èŠ‚ç‚¹æ’å…¥åŒæ­¥é˜Ÿåˆ—ï¼Œåœ¨å¿…è¦æ—¶è¿›è¡Œåˆå§‹åŒ–ã€‚åŒæ—¶ä¼šè¿”å›æ—§çš„å°¾ç»“ç‚¹
private Node enq(Node node) {
    for (;;) {
        Node oldTail = tail;
        if (oldTail != null) {
            // è®¾ç½®prevèŠ‚ç‚¹ï¼Œè¯¥æ“ä½œå¯¹äºå…¶å®ƒçº¿ç¨‹å¯è§
            node.setPrevRelaxed(oldTail);
            if (compareAndSetTail(oldTail, node)) {
                oldTail.next = node;
                return oldTail;
            }
        } else {
            // ä¸ºå¤´éƒ¨å’Œå°¾éƒ¨åˆå§‹åŒ–ä¸€ä¸ªå ä½èŠ‚ç‚¹
            initializeSyncQueue();
        }
    }
}
```

### 2.2.1 isOnSyncQueue

è¿™æ—¶æˆ‘ä»¬å†æ¥çœ‹`isOnSyncQueue`å°±å¯ä»¥å‘ç°æ¸…æ™°å¤šäº†ã€‚

é¦–å…ˆåœ¨è°ƒç”¨`isOnSyncQueue`ä¹‹å‰ï¼Œåˆ›å»ºçš„èŠ‚ç‚¹éƒ½æ˜¯åœ¨æ¡ä»¶é˜Ÿåˆ—é‡Œçš„ï¼ŒåŒæ­¥é˜Ÿåˆ—é‡Œå¹¶æ²¡æœ‰ç›¸å…³çš„èŠ‚ç‚¹ã€‚

```java
final boolean isOnSyncQueue(Node node) {
    // å¦‚æœèŠ‚ç‚¹çŠ¶æ€ä¸ºCONDITIONï¼Œè¯´æ˜ä¸€å®šä¸åœ¨åŒæ­¥é˜Ÿåˆ—ï¼Œæˆ‘ä»¬åœ¨ä¸Šé¢å¯ä»¥çœ‹åˆ°ï¼Œåœ¨èŠ‚ç‚¹è¿›å…¥åŒæ­¥é˜Ÿåˆ—å
    // å®ƒçš„waitStatusä¼šè¢«è®¾ç½®ä¸º0
    // ç¬¬äºŒä¸ªæ¡ä»¶åˆ™æ˜¯åˆ¤æ–­æ¡ä»¶é˜Ÿåˆ—å‰é¢æœ‰èŠ‚ç‚¹ï¼Œè¯´æ˜è‡ªå·±è‚¯å®šè¿˜åœ¨åŒæ­¥é˜Ÿåˆ—é‡Œ(è¿™é‡Œå­˜ç–‘)
    if (node.waitStatus == Node.CONDITION || node.prev == null)
        return false;
    // å¦‚æœå½“å‰èŠ‚ç‚¹æœ‰åç»­èŠ‚ç‚¹ï¼Œè¯´æ˜ä¸€å®šåœ¨åŒæ­¥é˜Ÿåˆ—ï¼Œå› ä¸ºå¯¹äºæ¡ä»¶é˜Ÿåˆ—ï¼Œæˆ‘ä»¬åªä¼šå”¤é†’å¤´ç»“ç‚¹ï¼Œä¸ä¼šè·Ÿ
    // åŒæ­¥é˜Ÿåˆ—ä¸€æ ·ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰å”¤é†’çš„æœºä¼šï¼Œè€Œä¸”è¢«å”¤é†’çš„æ—¶å€™ä¸€å®šæ˜¯æœ‰äººè°ƒç”¨äº†signalæˆ–è€…ä¸­æ–­
    if (node.next != null) // If has successor, it must be on queue
        return true;
    /*
         * node.prev can be non-null, but not yet on queue because
         * the CAS to place it on queue can fail. So we have to
         * traverse from tail to make sure it actually made it.  It
         * will always be near the tail in calls to this method, and
         * unless the CAS failed (which is unlikely), it will be
         * there, so we hardly ever traverse much.
         */
    // è¿™é‡Œç›´æ¥éå†åŒæ­¥é˜Ÿåˆ—ï¼ŒæŸ¥çœ‹æ˜¯å¦åœ¨é˜Ÿåˆ—é‡Œ
    return findNodeFromTail(node);
}
```

åœ¨åŒæ­¥é˜Ÿåˆ—é‡Œè¯´æ˜äº†ä»€ä¹ˆï¼Ÿè¯´æ˜å®ƒæœ‰æœºä¼šæ‹¿åˆ°é”ç»§ç»­è¿è¡Œï¼æ‰€ä»¥åœ¨`await`é‡Œå°±è¦è·³å‡ºå¾ªç¯ã€‚
