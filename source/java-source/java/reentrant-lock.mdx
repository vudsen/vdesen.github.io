---
title: AQS å’Œ ReentrantLock
date: 2023-03-08 12:37:15
categories:
  - Javaæºç 
seo:
  description: ReentrantLock å’Œ AQS æºç è¯¦è§£
---

> [!NOTE]
>  æºç åŸºäº Java 17 (Spring5 éƒ½åœæ­¢ç»´æŠ¤äº†ï¼Œæ˜¯æ—¶å€™å‡çº§äº†...).


åœ¨çœ‹å…·ä½“çœ‹åœ¨è¿™ä¹‹å‰æœ‰ä¸ªé—®é¢˜ï¼šè¯·è¯´è¯´ä½ å¯¹ `AQS` çš„ç†è§£ï¼Ÿ

é¢è¯•çš„æ—¶å€™è¢«é—®åˆ°è¿™ç§é—®é¢˜å°±å¾ˆè›‹ç–¼ï¼Œå› ä¸ºä½ å¯èƒ½çŸ¥é“å®ƒçš„åŸç†ï¼Œä½†æ˜¯ä¸çŸ¥é“æ€ä¹ˆæ¦‚æ‹¬å‡ºæ¥ã€‚

æ‰€ä»¥ä¸ªäººå»ºè®®åœ¨çœ‹æºç å‰ä¸€å®šè¦çœ‹ä¸€ä¸‹æ¯ä¸ªç±»ä¸Šçš„æ³¨é‡Šï¼Œæ¯”å¦‚è¯´è¿™é‡Œçš„ `AQS` (è¿™é‡Œåªæˆªå–äº†éƒ¨åˆ†):

> Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. 
>
> æä¾›äº†ä¸€ä¸ªæ¡†æ¶ï¼Œå»å¸®åŠ©å¼€å‘è€…å®ç°ä¸€ä¸ªä¾èµ–äºå…ˆè¿›å…ˆå‡º(FIFO)ç­‰å¾…é˜Ÿåˆ—çš„åŒæ­¥é”æˆ–ç›¸å…³åŒæ­¥å™¨(äº‹ä»¶ã€ä¿¡å·é‡ç­‰)

å¦‚æœè°ˆç†è§£çš„è¯ï¼Œç”¨è¿™ä¸€å¥å¼€å¤´å°±ä¼šå¾ˆèˆ’æœã€

# æ¦‚è¦

![ç±»ç»§æ‰¿å›¾](https://selfb.asia/public/java-source/2023-2-3-12046ac9-cd7f-4b31-9c43-6f398f6a86a3.webp)

å¯¹äº`ReentrantLock`ï¼Œä½ éœ€è¦çŸ¥é“å®ƒé‡Œé¢æœ‰ä¸€ä¸ª<span classname="text-error">ç­‰å¾…é˜Ÿåˆ—ï¼Œä¹Ÿå°±æ˜¯ AQS </span>(`AbstractQueuedSynchronizer`)ï¼Œ<span classname="text-error">è¿™ä¸ªé˜Ÿåˆ—åªæœ‰â€œå¤´éƒ¨çš„èŠ‚ç‚¹â€æ‰æœ‰èµ„æ ¼æŠ¢åˆ°é”ï¼ä½†è¿™å¹¶ä¸ä»£è¡¨å…¶å®ƒèŠ‚ç‚¹å¯¹åº”çš„çº¿ç¨‹ä¸ä¼šè¢«å”¤é†’ï¼Œè¿™äº›çº¿ç¨‹åªæ˜¯æ²¡æœ‰æŠ¢é”çš„èµ„æ ¼ï¼Œåœ¨è·å–èµ„æ ¼å‰æŠ¢é”æ°¸è¿œå¤±è´¥ã€‚åœ¨è¿™é‡Œéœ€è¦æ³¨æ„ï¼š**æ²¡æœ‰èµ„æ ¼æŠ¢é” != æ²¡æœ‰æœºä¼šè¢«å”¤é†’**ã€‚</span>

![AQSç¤ºä¾‹](https://selfb.asia/images/2024/09/AQS2.webp)

ä¾‹å¦‚ä¸Šå›¾ï¼Œæ˜¯ AQS çš„ä¸€ä¸ªç®€å•ç¤ºä¾‹ã€‚`state` è¡¨ç¤ºé˜Ÿåˆ—çŠ¶æ€ï¼Œå¦‚æœè¯¥å€¼é 0ï¼Œåˆ™è¡¨ç¤ºé”å·²ç»è¢«å…¶å®ƒçº¿ç¨‹å ç”¨ã€‚è¿™é‡Œ `Node0` ç›®å‰å·²ç»æ˜¯æŠ¢åˆ°é”çš„çŠ¶æ€ï¼Œå…¶ä½™èŠ‚ç‚¹éƒ½å¤„äºç­‰å¾…(æŒ‚èµ·)çŠ¶æ€ã€‚

å½“ `Node0` é‡Šæ”¾é”æ—¶ï¼Œå®ƒå°†ä¼šå”¤é†’ `Node1#waiter` å¯¹åº”çš„çº¿ç¨‹ï¼Œå¹¶å»é™¤æ‰ `WAITING` çš„ `status`ï¼Œæ­¤æ—¶ `Node1` å‘ç°è‡ªå·±å¤„äº*ç¬¬ä¸€ä¸ª*ï¼Œå°±ä¼šå°è¯•æŠ¢é”ã€‚å¦‚æœæˆåŠŸï¼Œåˆ™å°† `head` æŒ‡å‘ä¸ºè‡ªå·±ã€‚

> [!NOTE]
> ç¬¬ä¸€ä¸ªï¼šå½“ `node.prev == head` æ—¶ï¼Œå½“å‰èŠ‚ç‚¹å°±æ˜¯ç¬¬ä¸€ä¸ªã€‚

å¯¹äº `Node2`ï¼Œç”±äºå®ƒä¸æ˜¯*ç¬¬ä¸€ä¸ª*èŠ‚ç‚¹ï¼Œæ‰€ä»¥å®ƒä¼šåœ¨æŠ¢é”æ—¶ç›´æ¥è¿›å…¥ `WAITING` çŠ¶æ€ã€‚

## CHL

å…¶å®[æ–‡æ¡£](https://github.com/openjdk/jdk/blob/dfacda488bfbe2e11e8d607a6d08527710286982/src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java#L316-L446)å·²ç»å¾ˆæ¸…æ™°çš„è¯´æ˜äº† AQS æ˜¯æ€ä¹ˆå®ç°çš„äº†ï¼Œå¦‚æœæœ‰èƒ½åŠ›ï¼Œå¯ä»¥ç›´æ¥ç¡¬å•ƒæ–‡æ¡£ã€‚å› ä¸ºå­—æ•°è¿‡å¤šï¼Œè¿™é‡Œæˆ‘åªæ‘˜å‡ºä¸€éƒ¨åˆ†ã€‚

---

CLH å¯ä»¥é¿å…ä½¿ç”¨åŒæ­¥é”ï¼Œé€šè¿‡ `prev` å’Œ `next` å¯¹å‰åèŠ‚ç‚¹çš„è¿æ¥ä»¥åŠ `status` å­—æ®µï¼Œå½“çº¿ç¨‹é‡Šæ”¾é”æ—¶ï¼ŒCLH é˜Ÿåˆ—å¯ä»¥ç»™å®ƒçš„ç»§ä»»è€…å‘é€ä¸€ä¸ªä¿¡å·ï¼Œæ­¤æ—¶ç»§ä»»è€…å¯ä»¥è¿›ä¸€æ­¥è¿›è¡ŒæŠ¢é”æ“ä½œã€‚

```text
 +------+  prev +-------+       +------+
 | head | <---- | first | <---- | tail |
 +------+       +-------+       +------+
```

å‘ CLH æ’å…¥èŠ‚ç‚¹åªéœ€è¦åœ¨ `tail` æ‰§è¡Œä¸€ä¸ªåŸå­æ“ä½œã€‚å½“ CAS æ“ä½œæ‰§è¡ŒæˆåŠŸåï¼Œåªéœ€è¦å†å°†ä¹‹å‰çš„ `tail.next` è®¾ç½®ä¸ºè‡ªå·±å³å¯ã€‚å³ä½¿åé¢åé¢è¿™ä¸€æ­¥ä¸æ˜¯åŸå­æ“ä½œï¼Œ
ä½†æ˜¯ä¹Ÿè¶³å¤Ÿç¡®ä¿ä»»ä½•è¢«é˜»å¡çš„çº¿ç¨‹ï¼Œéƒ½èƒ½å¤ŸæˆåŠŸçš„æ¥æ”¶åˆ°å‰ä»»è€…çš„ä¿¡å·(ä¾‹å¦‚ `Node0` æ˜¯å½“å‰çš„ `tail`ï¼Œæ­¤æ—¶ CAS æ’å…¥ `Node1` çš„åŒæ—¶ `Node0` çš„é”é‡Šæ”¾æ‰äº†ï¼Œæ­¤æ—¶ `Node0.next` ä¸ºç©ºï¼Œä½†æ˜¯ä»ç„¶ä¸å½±å“ä»£ç çš„æ­£å¸¸è¿è¡Œ)ã€‚


# æºç 

## æ„é€ å™¨

```java
/**
 * Creates an instance of {@code ReentrantLock}.
 * This is equivalent to using {@code ReentrantLock(false)}.
 */
public ReentrantLock() {
  sync = new NonfairSync();
}

/**
 * Creates an instance of {@code ReentrantLock} with the
 * given fairness policy.
 *
 * @param fair {@code true} if this lock should use a fair ordering policy
 */
public ReentrantLock(boolean fair) {
  sync = fair ? new FairSync() : new NonfairSync();
}
```

å¯ä»¥é€šè¿‡æ„é€ å™¨æ¥è®¾ç½®é”æ˜¯å¦ä¸ºå…¬å¹³é”ï¼Œé»˜è®¤ä¸ºéå…¬å¹³é”

å…¬å¹³é”å’Œéå…¬å¹³é”çš„å”¯ä¸€åŒºåˆ«å°±æ˜¯å…¬å¹³é”å¤šäº†ä¸€ä¸ªåˆ¤æ–­æ¡ä»¶ï¼š`hasQueuedPredecessors`ã€‚è¯¥æ–¹æ³•ä¸»è¦ç”¨äºåˆ¤æ–­å…¬å¹³é”åŠ é”æ—¶ç­‰å¾…é˜Ÿåˆ—ä¸­æ˜¯å¦å­˜åœ¨æœ‰æ•ˆèŠ‚ç‚¹ã€‚

```java
// å…¬å¹³é”
@ReservedStackAccess
protected final boolean tryAcquire(int acquires) {
  final Thread current = Thread.currentThread();
  int c = getState();
  if (c == 0) {
    // å…¬å¹³åªæ¯”éå…¬å¹³é”å¤šäº†ä¸‹é¢ä¸€ä¸ªæ¡ä»¶ï¼Œå…¶ä½™å’Œéå…¬å¹³é”ä¸€æ ·ã€‚
    // è¿™é‡Œä¼šåˆ¤æ–­é˜Ÿåˆ—ä¸­æ˜¯å¦æœ‰æ­£åœ¨æ’é˜Ÿçš„çº¿ç¨‹ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™ç›´æ¥æŠ¢é”ï¼Œä¸è¿›é˜Ÿåˆ—äº†
    if (!hasQueuedPredecessors() &&
      compareAndSetState(0, acquires)) {
      setExclusiveOwnerThread(current);
      return true;
    }
  }
  else if (current == getExclusiveOwnerThread()) {
    int nextc = c + acquires;
    if (nextc < 0)
      throw new Error("Maximum lock count exceeded");
    setState(nextc);
    return true;
  }
  return false;
}
```

è¿™é‡Œå¯ä»¥å‘ç°ï¼Œå¦‚æœæ˜¯éå…¬å¹³é”ï¼Œçº¿ç¨‹åœ¨å…¥é˜Ÿä¹‹å‰æ€»ä¼šå°è¯•æŠ¢é”ï¼Œå¦‚æœæŠ¢åˆ°äº†å°±ä¸ä¼šå…¥é˜Ÿäº†ã€‚å¦‚æœæ˜¯å…¬å¹³é”å…¥é˜Ÿå‰ï¼Œåªä¼šåœ¨ç­‰å¾…é˜Ÿåˆ—ä¸ºç©ºæ—¶å°è¯•æŠ¢é”ï¼Œå¦åˆ™éœ€è¦è€è€å®å®å…¥é˜Ÿã€‚

> [!IMPORTANT]
> è¿™é‡Œä»¥éå…¬å¹³é”ä¸ºä¾‹æ¼”ç¤ºï¼Œå½“ä»£ç ä¸ä¸€æ ·æ—¶ä¼šå•ç‹¬æŒ‡å‡ºï¼Œå¦åˆ™è¡¨ç¤ºä¸¤è¾¹å®ç°ä¸€æ ·ã€‚

## lock

`lock`æ–¹æ³•ä¸»è¦è°ƒç”¨äº†AQSä¸­çš„`acquire`æ–¹æ³•

```java
// è¯¥æ–¹æ³•æ˜¯RentrantLocké‡Œçš„
final void lock() {
  if (!initialTryLock())
    acquire(1);
}

// éå…¬å¹³é”
final boolean initialTryLock() {
  Thread current = Thread.currentThread();
  if (compareAndSetState(0, 1)) { // first attempt is unguarded
    setExclusiveOwnerThread(current);
    return true;
  } else if (getExclusiveOwnerThread() == current) {
    int c = getState() + 1;
    if (c < 0) // overflow
      throw new Error("Maximum lock count exceeded");
    setState(c);
    return true;
  } else
    return false;
}

// å…¬å¹³é”
final boolean initialTryLock() {
  Thread current = Thread.currentThread();
  int c = getState();
  if (c == 0) {
    if (!hasQueuedThreads() && compareAndSetState(0, 1)) {
      setExclusiveOwnerThread(current);
      return true;
    }
  } else if (getExclusiveOwnerThread() == current) {
    if (++c < 0) // overflow
      throw new Error("Maximum lock count exceeded");
    setState(c);
    return true;
  }
  return false;
}

// è¯¥æ–¹æ³•æ˜¯AQSç±»é‡Œçš„
public final void acquire(int arg) {
  if (!tryAcquire(arg))
    acquire(null, arg, false, false, false, 0L);
}
```

> [!IMPORTANT]
> å¯ä»¥å‘ç°å…¬å¹³é”å’Œéå…¬å¹³é”çš„å”¯ä¸€åŒºåˆ«å°±æ˜¯ï¼šå…¬å¹³é”åœ¨æ²¡å…¥é˜Ÿå‰æŠ¢é”æ€»æ˜¯éœ€è¦åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºã€‚
>
> è¿™é‡Œåé¢å°±åªå±•ç¤º**éå…¬å¹³é”**çš„ä»£ç äº†ã€‚

å¤§è‡´æµç¨‹æµç¨‹:

<PintoraDiagram code={`
activityDiagram
title: lock æµç¨‹
start
if(é”ç©ºé—²å¹¶ä¸”æŠ¢é”æˆåŠŸ)then
  :æŠ¢é”æˆåŠŸ;
  end
else(no)
  :ç»§ç»­æŠ¢é”;
endif
if (å½“å‰çº¿ç¨‹æ˜¯å¦ä¸ºå·²ç»æŒæœ‰é”çš„çº¿ç¨‹)then
  :state + 1 æ ‡è®°é‡å…¥ 1 æ¬¡;
  :æŠ¢é”æˆåŠŸ;
  end
else(no)
endif
:å°è¯•è¿›å…¥ç­‰å¾…é˜Ÿåˆ—ç»§ç»­æŠ¢é”;
end
`}/>


### tryAcquire

AQS ä½¿ç”¨äº†æ¨¡æ¿æ¨¡å¼ï¼Œè¿™é‡Œ `tryAcquire` æ˜¯ä¸€ä¸ªæ¨¡æ¿æ–¹æ³•ï¼Œéœ€è¦å­ç±»å®ç°ã€‚è¯¥æ–¹æ³•ä¼šå…ˆå°è¯•æŠ¢å é” (å°è¯•å°† `status` ä» `0` è®¾ç½®ä¸º`1` )ï¼Œè‹¥å¤±è´¥åˆ™ç»§ç»­åˆ¤æ–­:

```java
protected final boolean tryAcquire(int acquires) {
  if (getState() == 0 && compareAndSetState(0, acquires)) {
    setExclusiveOwnerThread(Thread.currentThread());
    return true;
  }
  return false;
}
```

### acquire

å¦‚æœ`tryAcquire`æ²¡æœ‰æ‹¿åˆ°é”ï¼Œåˆ™ä¼šè¿›å…¥è¿™ä¸€æ­¥ï¼šå°†çº¿ç¨‹åŠ å…¥åˆ°ç­‰å¾…é˜Ÿåˆ—ã€‚ä»£ç å¾ˆé•¿ï¼š

```java
final int acquire(Node node, int arg, boolean shared,
                    boolean interruptible, boolean timed, long time) {
  Thread current = Thread.currentThread();
  byte spins = 0, postSpins = 0;   // retries upon unpark of first thread
  boolean interrupted = false, first = false;
  Node pred = null;                // predecessor of node when enqueued

  /*
      * Repeatedly:
      *  Check if node now first
      *    if so, ensure head stable, else ensure valid predecessor
      *  if node is first or not yet enqueued, try acquiring
      *  else if node not yet created, create it
      *  else if not yet enqueued, try once to enqueue
      *  else if woken from park, retry (up to postSpins times)
      *  else if WAITING status not set, set and retry
      *  else park and clear WAITING status, and check cancellation
      */
  for (;;) {
    if (!first && (pred = (node == null) ? null : node.prev) != null &&
      !(first = (head == pred))) {
      if (pred.status < 0) {
        cleanQueue();           // predecessor cancelled
        continue;
      } else if (pred.prev == null) {
        Thread.onSpinWait();    // ensure serialization
        continue;
      }
    }
    if (first || pred == null) { // ä¸ºç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæˆ–è€…è¿˜æ²¡æœ‰å…¥é˜Ÿï¼Œç›´æ¥å°è¯•æŠ¢é”
      boolean acquired;
      try {
        if (shared)
          acquired = (tryAcquireShared(arg) >= 0);
        else
          acquired = tryAcquire(arg);
      } catch (Throwable ex) {
        cancelAcquire(node, interrupted, false);
        throw ex;
      }
      if (acquired) {
        if (first) { // å°†è‡ªå·±è®¾ç½®ä¸ºç¬¬ä¸€ä¸ªèŠ‚ç‚¹
          node.prev = null;
          head = node;
          pred.next = null;
          node.waiter = null;
          if (shared)
              signalNextIfShared(node);
          if (interrupted)
              current.interrupt();
        }
        return 1;
      }
    }
    if (node == null) {                 // åˆ›å»ºèŠ‚ç‚¹å¹¶é‡æ–°å¾ªç¯
      if (shared)
        node = new SharedNode();
      else
        node = new ExclusiveNode();
    } else if (pred == null) {          // å°è¯•å°†èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—(å°¾æ’)
      node.waiter = current;
      Node t = tail;
      node.setPrevRelaxed(t);         // è¿™é‡Œä½¿ç”¨ unsafe èµ‹å€¼ï¼Œé¿å…äº†è¯»å†™å±éšœå¯¼è‡´æ•°æ®ä¸ä¸€è‡´
      if (t == null)
        tryInitializeHead();
      else if (!casTail(t, node))     // å°è¯• CAS è®¾ç½®å°¾ç»“ç‚¹
        node.setPrevRelaxed(null);  // back out
      else
        t.next = node;
    } else if (first && spins != 0) {
      --spins;                        // reduce unfairness on rewaits, è¿™é‡Œåé¢è¯´
      Thread.onSpinWait();            // æŒ‡ç¤ºå½“å‰çº¿ç¨‹æš‚æ—¶æ— æ³•åœ¨å¾ªç¯ä¸­å®Œæˆä»»åŠ¡ï¼ŒJVMä¼šä¼˜åŒ–æ­¤ç±»å¾ªç¯ä»¥æé«˜æ€§èƒ½
    } else if (node.status == 0) {      // çŠ¶æ€ä¸º 0 è¡¨ç¤ºæ­£åœ¨æŠ¢é”
      node.status = WAITING;          // è®¾ç½®èŠ‚ç‚¹çŠ¶æ€ä¸ºç­‰å¾…
    } else {
      long nanos; // æŒ‚èµ·çº¿ç¨‹ï¼Œç­‰å¾…ä¸‹æ¬¡å”¤é†’
      spins = postSpins = (byte)((postSpins << 1) | 1); // è¿™é‡Œåé¢è¯´
      if (!timed)
        LockSupport.park(this);
      else if ((nanos = time - System.nanoTime()) > 0L)
        LockSupport.parkNanos(this, nanos);
      else
        break;
      node.clearStatus();
      if ((interrupted |= Thread.interrupted()) && interruptible)
        break;
    }
  }
  return cancelAcquire(node, interrupted, interruptible);
}
```

è¿™é‡Œåœ¨æ³¨é‡Šé‡Œå·²ç»è®²çš„å¾ˆæ¸…æ¥šäº†ï¼Œä¸»è¦å¹²äº†è¿™ä¹ˆå‡ ä»¶äº‹ï¼š

1. if æ˜¯ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç¡®ä¿ç»§ä»»è€…æœ‰æ•ˆ(åˆæ³•)
2. if èŠ‚ç‚¹æ˜¯ç¬¬ä¸€ä¸ªå¹¶ä¸”è¿˜æ²¡æœ‰å…¥é˜Ÿï¼Œåˆ™å°è¯•æŠ¢é”
3. else if èŠ‚ç‚¹æ²¡æœ‰è¢«åˆ›å»ºï¼Œåˆ™åˆ›å»ºå¯¹åº”çš„èŠ‚ç‚¹
4. else if èŠ‚ç‚¹æ²¡æœ‰å…¥é˜Ÿï¼Œåˆ™å°è¯•å…¥é˜Ÿ
5. else if çº¿ç¨‹è¢«å”¤é†’ï¼Œåˆ™é‡æ–°è‡ªæ—‹å¹¶è®¾ç½®æ›´å¤§çš„ `spins` ä»¥é˜²æ­¢ä¸€ç›´æŠ¢ä¸åˆ°é”
6. else if WAITING çŠ¶æ€æ²¡æœ‰è¢«è®¾ç½®ï¼Œåˆ™è®¾ç½®å¹¶è¯¥çŠ¶æ€å¹¶é‡è¯•
7. else æŒ‚èµ·çº¿ç¨‹ï¼Œç„¶åæ¸…é™¤ WAITING çŠ¶æ€å¹¶æ£€æŸ¥å–æ¶ˆ(ä¸­æ–­)è¯·æ±‚

åœ¨ç»§ç»­å‰ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹èŠ‚ç‚¹çš„ `status` æœ‰å“ªäº›:

```java
// è¡¨ç¤ºå½“å‰èŠ‚ç‚¹æ­£åœ¨ç­‰å¾…ä¿¡å·
static final int WAITING   = 1;          // must be 1
// è¡¨ç¤ºå½“å‰èŠ‚ç‚¹å·²ç»è¢«å–æ¶ˆäº†ï¼Œå³æ”¾å¼ƒæŠ¢é”
static final int CANCELLED = 0x80000000; // must be negative. 1000 0000 0000 0000 0000 0000 0000 0001
// è¡¨ç¤ºå½“å‰èŠ‚ç‚¹å·²ç»è¢«æŒ‚èµ·ï¼Œæ­£åœ¨ç­‰å¾…å”¤é†’ä¿¡å·
static final int COND      = 2;          // in a condition wait
```

è¿™é‡Œ `COND` åé¢å†è¯´ï¼Œ`ReentrantLock` é‡Œé¢æ²¡æœ‰ç”¨åˆ°ã€‚`WAITING` åˆ™æ˜¯è¡¨ç¤ºå½“å‰èŠ‚ç‚¹æ­£åœ¨ç­‰å¾…ä¿¡å·ã€‚

### cleanQueue

è¿™é‡Œ[ä»£ç ](https://github.com/openjdk/jdk/blob/dfacda488bfbe2e11e8d607a6d08527710286982/src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java#L733-L761)å¾ˆæ¶å¿ƒï¼Œå˜é‡åç§°å…¨éƒ¨ç”¨ä¸€ä¸ªå­—ç¬¦è¡¨ç¤ºï¼Œè¿™é‡Œæˆ‘æŠŠå®ƒæ¢æˆäº†ç¨å¾®èƒ½ç†è§£çš„åç§°ï¼š

```java
private void cleanQueue() {
  for (;;) {                               // restart point
    for (Node currentNode = tail, nextNode = null, prevNode, prevNext;;) { // (prevNode, currentNode, nextNode) triples
      if (currentNode == null || (prevNode = currentNode.prev) == null)
        return;                      // end of list
      if (nextNode == null ? tail != currentNode : (nextNode.prev != currentNode || nextNode.status < 0))
        break;                       // inconsistent
      if (currentNode.status < 0) {              // cancelled
        if ((nextNode == null ? casTail(currentNode, prevNode) : nextNode.casPrev(currentNode, prevNode)) &&
          currentNode.prev == prevNode) {
          prevNode.casNext(currentNode, nextNode);         // OK if fails
          if (prevNode.prev == null)
            signalNext(prevNode);
        }
        break;
      }
      if ((prevNext = prevNode.next) != currentNode) {         // help finish
        if (prevNext != null && currentNode.prev == prevNode) {
          prevNode.casNext(prevNext, currentNode);
          if (prevNode.prev == null)
            signalNext(prevNode);
        }
        break;
      }
      nextNode = currentNode;
      currentNode = currentNode.prev;
    }
  }
}
```
æœ€åè¿™æ®µ `help finish` å¯èƒ½æœ‰ç‚¹è¿·ï¼Œä¸ºä»€ä¹ˆè¿˜è¦å¸®åˆ«äººå®ŒæˆèŠ‚ç‚¹è¿æ¥ï¼Œè¿™é‡Œæˆ‘ä»¬å¯ä»¥çœ‹ä¸€ä¸‹[å‰é¢çš„ä»£ç ](https://github.com/openjdk/jdk/blob/dfacda488bfbe2e11e8d607a6d08527710286982/src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java#L697-L705)æˆ‘ä»¬æ˜¯æ€ä¹ˆæŠŠèŠ‚ç‚¹æ’å…¥åˆ°é˜Ÿåˆ—ä¸­çš„:

```java
node.waiter = current;
Node t = tail;
node.setPrevRelaxed(t);         // avoid unnecessary fence
if (t == null)
  tryInitializeHead();
else if (!casTail(t, node))
  node.setPrevRelaxed(null);  // back out
else
  t.next = node;
```

å¯ä»¥å‘ç° `casTail(t, node)` å’Œ `t.next = node` å¹¶ä¸æ˜¯ä¸€ä¸ªåŸå­æ“ä½œï¼Œæ‰€ä»¥åœ¨é«˜å¹¶å‘ä¸‹ï¼Œå¯èƒ½å¯¼è‡´ `t.next = node` è¿˜æ²¡è¢«æ‰§è¡Œï¼Œå°±è¢«å…¶å®ƒçº¿ç¨‹è§†ä½œè¿›å…¥é˜Ÿåˆ—äº†ã€‚

> [!NOTE]
> è¯´å®è¯ï¼Œæˆ‘ç›®å‰æ²¡æœ‰æƒ³åˆ°ä¸å¸®å¿™ä¼šå‡ºç°ä»€ä¹ˆé—®é¢˜ğŸ« ...ä½†æ˜¯è‚¯å®šæ˜¯æœ‰ç‚¹éšæ‚£åœ¨è¿™é‡Œçš„ã€‚

### cancelAcquire

è¿™ä¸ªæ–¹æ³•å¾ˆç®€å•ï¼Œç›´æ¥çœ‹å°±èƒ½çœ‹æ‡‚ï¼š

```java
private int cancelAcquire(Node node, boolean interrupted,
                            boolean interruptible) {
  if (node != null) {
    node.waiter = null;
    node.status = CANCELLED;
    if (node.prev != null)
      cleanQueue();
  }
  if (interrupted) {
    if (interruptible)
      return CANCELLED;
    else
      Thread.currentThread().interrupt();
  }
  return 0;
}
```


## unlock

```java
// Syncç±»çš„æ–¹æ³•
public void unlock() {
  sync.release(1);
}

// AQSçš„æ–¹æ³•
public final boolean release(int arg) {
  if (tryRelease(arg)) {
    signalNext(head);
    return true;
  }
  return false;
}

// Syncç±»çš„æ–¹æ³•
protected final boolean tryRelease(int releases) {
  int c = getState() - releases;
  if (getExclusiveOwnerThread() != Thread.currentThread())
    throw new IllegalMonitorStateException();
  boolean free = (c == 0);
  if (free)
    setExclusiveOwnerThread(null);
  setState(c);
  return free;
}
```

è§£é”çš„ä»£ç éƒ½å¾ˆç®€å•ï¼Œå› ä¸ºå·²ç»å æœ‰äº†é”ï¼Œæ‰€ä»¥ä¸éœ€è¦è¿‡å¤šåˆ¤æ–­ã€‚

### å¤´èŠ‚ç‚¹çš„é‡Šæ”¾

å…ˆæ¥çœ‹ä¸€ä¸‹ `signalNext`:

```java
private static void signalNext(Node h) {
  Node s;
  if (h != null && (s = h.next) != null && s.status != 0) {
    s.getAndUnsetStatus(WAITING);
    LockSupport.unpark(s.waiter);
  }
}
```

è¿™æ®µä»£ç å¾ˆç®€å•ï¼Œåªæ˜¯å–æ¶ˆäº†ç»§ä»»è€…çš„ `WAITING` çŠ¶æ€å¹¶å”¤é†’å®ƒã€‚

å¯ä»¥å‘ç° AQS çš„ `release` æ–¹æ³•æ²¡æœ‰å¯¹ä»»ä½•èŠ‚ç‚¹è¿›è¡Œåˆ é™¤ï¼Œè¿™é‡Œå°±éå¸¸å·§å¦™çš„åˆ©ç”¨äº†åªæœ‰*ç¬¬ä¸€ä¸ª*èŠ‚ç‚¹æ‰èƒ½æŠ¢é”çš„ç‰¹æ€§æ¥å¯¹èŠ‚ç‚¹è¿›è¡Œäº†åˆ é™¤ã€‚åœ¨åé¢*ç¬¬ä¸€ä¸ª*èŠ‚ç‚¹æŠ¢åˆ°é”åï¼Œå®ƒä¼šå°†è‡ªå·±è®¾ç½®ä¸ºæ–°çš„ `tail`ï¼Œæ—§çš„ `tail` å› æ­¤è¢«ä¸¢å¼ƒï¼Œæœ€åè¢«åƒåœ¾å›æ”¶ã€‚

## æ€»ç»“

æœ€åç”¨ä¸€å¼ å›¾æ€»ç»“ä¸€ä¸‹å§ï¼š
<PintoraDiagram code={`
activityDiagram
title: lock
start
:å¼€å§‹æŠ¢é”;
switch(å¼€å§‹æŠ¢é”)
case(CAS lock success)
  :è®¾ç½®ç‹¬å ;
  end
case(å…¶å®ƒ)
case(Already locked)
  :é‡å…¥æ¬¡æ•° + 1;
  end
endswitch
if(å†æ¬¡å°è¯•æŠ¢é”)then
  :è®¾ç½®ç‹¬å ;
  end
else
   :continue;
endif
while(å¾ªç¯æŠ¢é”ï¼Œç›´åˆ°æˆåŠŸæˆ–å–æ¶ˆ)
if(æ˜¯ç¬¬ä¸€ä¸ªèŠ‚ç‚¹)then
  if(å°è¯•æŠ¢é”)then
    :è®¾ç½®ç‹¬å ï¼Œå¹¶å°†é˜Ÿåˆ—å¤´éƒ¨æŒ‡å‘è‡ªå·±;
    end
  else
    :ç»§ç»­;
  endif
else
  :cleanQueue;
endif
if(èŠ‚ç‚¹æœªåˆ›å»º)then
  :åˆ›å»ºèŠ‚ç‚¹;
else
  if(èŠ‚ç‚¹çš„prevä¸ºç©º)then
    :å°è¯•å°†èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—;
  else
    if(æ˜¯ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å¹¶ä¸”è‡ªæ—‹æ¬¡æ•°ä¸ä¸º0)then
      :è‡ªæ—‹æ¬¡æ•°å‡ä¸€, ç»§ç»­å¾ªç¯;
    else
      if(èŠ‚ç‚¹ status == 0)then
        :è®¾ç½®èŠ‚ç‚¹çŠ¶æ€ä¸ºWAITING;
      else
        :æé«˜è‡ªæ—‹æ¬¡æ•°, å¹¶æŒ‚èµ·çº¿ç¨‹;
        -> è¢«å”¤é†’;
        :å°†çŠ¶æ€è®¾ç½®ä¸º0;
      endif
    endif
  endif
endif
endwhile
:æŠ¢é”æˆåŠŸ;
end
`}/>
![æ€»ç»“](https://selfb.asia/public/java-source/2023-2-3-aa7d1ca2-677d-4c91-b6b4-411036b452c2.webp)

# Condition

```java
ReentrantLock lock = new ReentrantLock();

Condition condition = lock.newCondition();

new Thread(() -> {
    lock.lock();
    System.out.println("Thread 1 locked.");
    try {
        condition.await();
        System.out.println("Thread 1 awake");
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
}).start();

Thread.sleep(1000);

new Thread(() -> {
    lock.lock();
    System.out.println("Thread 2 locked.");
    condition.signal();
    System.out.println("Thread 2 after signal");
    lock.unlock();
}).start();

Thread.sleep(3000);
```

è¾“å‡ºï¼š

```log
Thread 1 locked.
Thread 2 locked.
Thread 2 after signal
Thread 1 awake
```

å¯¹äº`Condition`ï¼Œè¿™é‡Œæˆ‘ä»¬æ¥äº†è§£ä¸€ä¸‹ `await` å’Œ `signal` è¿™ä¿©ä¸ªé‡è¦çš„æ–¹æ³•ã€‚ä»æ–¹æ³•åå¤§è‡´å°±å¯ä»¥çŒœå‡ºè¿™ä¿©æ˜¯å¹²ä»€ä¹ˆçš„äº†ï¼Œçº¿ç¨‹é€šè¿‡è°ƒç”¨ `await` å¯ä»¥é˜»å¡è‡ªå·±ï¼Œç„¶åå…¶å®ƒçº¿ç¨‹å¯ä»¥è°ƒç”¨ `signal` å’Œ `signalAll` æ¥å”¤é†’ä¸€ä¸ªæˆ–æ‰€æœ‰è¢«é˜»å¡çš„çº¿ç¨‹ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼š

- è°ƒç”¨ `await` å’Œ `signal` å‰å¿…é¡»æŒæœ‰é”
- è°ƒç”¨ `signal` åéœ€è¦æ‰‹åŠ¨é‡Šæ”¾é”

## newCondition ä¸­çš„éé™æ€å†…éƒ¨ç±»

è¿™é‡Œå¦‚æœæµ…çœ‹ `newCondition` æºç çš„è¯ï¼Œä¼šå‘ç° `newCondition` åªæ˜¯åˆ›å»ºå¹¶è¿”å›äº†ä¸€ä¸ªæ–°çš„å¯¹è±¡ï¼š

```java
public Condition newCondition() {
  return sync.newCondition();
}

abstract static class Sync extends AbstractQueuedSynchronizer {

  final ConditionObject newCondition() {
      return new ConditionObject();
  }

}
```

å¦‚æœä¸ç»†çœ‹çš„è¯è¿™é‡Œä¼šå¾ˆæ‡µé€¼: ä¸ºä»€ä¹ˆç›´æ¥è¿”å›äº†ä¸€ä¸ªå¯¹è±¡å¹¶ä¸”æ²¡æœ‰å’Œä»»ä½•ä¸œè¥¿è¿›è¡Œå…³è”?

å…¶å®åªè¦ç»†çœ‹å°±å¯ä»¥å‘ç°ï¼Œ`ConditionObject` æ˜¯ AQS ä¸­çš„ä¸€ä¸ª**éé™æ€å†…éƒ¨ç±»**ï¼Œåœ¨åˆ›å»ºåæ˜¯å¯ä»¥è®¿é—®å½“å‰ `ReentrantLock` å®ä¾‹å¯¹è±¡çš„(`this` è®¿é—®)ã€‚

## await

åœ¨çœ‹ä¹‹å‰éœ€è¦äº†è§£ä¸€ä¸ªç±»ï¼š`ConditionNode`ã€‚å®šä¹‰å¦‚ä¸‹ï¼š

```java
static final class ConditionNode extends Node
  implements ForkJoinPool.ManagedBlocker {
  ConditionNode nextWaiter;            // link to next waiting node

  public final boolean isReleasable() {
      return status <= 1 || Thread.currentThread().isInterrupted();
  }

  public final boolean block() {
      while (!isReleasable()) LockSupport.park();
      return true;
  }
}
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ`ConditionNode` ç»§æ‰¿äº† `Node`ï¼Œé¦–å…ˆ `ConditionNode` ä¼šåœ¨**æ¡ä»¶é˜Ÿåˆ—**ä¸­ç­‰å¾…å”¤é†’ï¼Œåœ¨å”¤é†’å‰ï¼Œå®ƒä¼šè¢«æ’å…¥åˆ°ç­‰å¾…é˜Ÿåˆ—ï¼Œå”¤é†’åï¼Œå°±å¯ä»¥ç›´æ¥å»æŠ¢é”äº†ã€‚

> [!NOTE]
> æ¡ä»¶é˜Ÿåˆ—æ˜¯ç”± `ConditionNode#nextWaiter` ç»„æˆçš„å•å‘é˜Ÿåˆ—ã€‚

---

```java
public final void await() throws InterruptedException {
  if (Thread.interrupted())
    throw new InterruptedException();
  // è¿™ä¸ª node æ˜¯ä¸€ä¸ªå•å‘é“¾è¡¨
  ConditionNode node = new ConditionNode();
  // å°†èŠ‚ç‚¹æ’å…¥åˆ° æ¡ä»¶é˜Ÿåˆ— é“¾è¡¨å°¾éƒ¨
  // æ’å…¥åå°†èŠ‚ç‚¹çŠ¶æ€è®¾ç½®ä¸º COND | WAITINGï¼Œå¹¶**é‡Šæ”¾é”**, å› ä¸ºå¿…é¡»æŒæœ‰é”è°ƒç”¨ï¼Œæ‰€ä»¥å®ç°å¾ˆç®€å•
  int savedState = enableWait(node);

  LockSupport.setCurrentBlocker(this); // for back-compatibility
  boolean interrupted = false, cancelled = false, rejected = false;
  // canReacquire: æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦è¿›å…¥ç­‰å¾…é˜Ÿåˆ—(CLHé˜Ÿåˆ—)
  while (!canReacquire(node)) {
    if (interrupted |= Thread.interrupted()) {
      if (cancelled = (node.getAndUnsetStatus(COND) & COND) != 0)
        break;              // else interrupted after signal
    } else if ((node.status & COND) != 0) {
      try {
        if (rejected)
          node.block();
        else
          // é˜»å¡ï¼Œç›´åˆ°ä¸‹æ¬¡å”¤é†’
          ForkJoinPool.managedBlock(node);
      } catch (RejectedExecutionException ex) {
        rejected = true;
      } catch (InterruptedException ie) {
        interrupted = true;
      }
    } else
      Thread.onSpinWait();    // awoke while enqueuing
  }
  // while å¾ªç¯ç»“æŸï¼Œä»£è¡¨ node å·²ç»è¿›å…¥äº†ç­‰å¾…é˜Ÿåˆ—
  LockSupport.setCurrentBlocker(null);
  // å°†çŠ¶æ€æ¸…é›¶
  node.clearStatus();
  // æŠ¢é”
  acquire(node, savedState, false, false, false, 0L);
  if (interrupted) {
      if (cancelled) {
          unlinkCancelledWaiters(node);
          throw new InterruptedException();
      }
      Thread.currentThread().interrupt();
  }
}
```

æ¥çœ‹ä¸€ä¸‹ `canReacquire`:

```java
private boolean canReacquire(ConditionNode node) {
  // check links, not status to avoid enqueue race
  Node p; // traverse unless known to be bidirectionally linked
  return node != null && (p = node.prev) != null &&
      (p.next == node || isEnqueued(node));
}
```

å®é™…å°±æ˜¯å»è®¿é—®ç­‰å¾…é˜Ÿåˆ—çš„å‰åèŠ‚ç‚¹æ£€æŸ¥æ˜¯å¦å…¥é˜Ÿï¼Œæœ€åçš„ `isEnqueued` ä¼šéå†æ•´ä¸ªç­‰å¾…é˜Ÿåˆ—ï¼Œæœç´¢ `node` æ˜¯å¦åœ¨é˜Ÿåˆ—ä¸­ã€‚

## signal

```java
public final void signal() {
  ConditionNode first = firstWaiter;
  if (!isHeldExclusively())
    throw new IllegalMonitorStateException();
  if (first != null)
    doSignal(first, false);
}
```

é¦–å…ˆä¼šåˆ¤æ–­å½“å‰çº¿ç¨‹æ˜¯å¦æŒæœ‰é”ï¼Œç„¶åä¼šè¿›ä¸€æ­¥å¤„ç†æ¡ä»¶é˜Ÿåˆ—ä¸­çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚

```java
private void doSignal(ConditionNode first, boolean all) {
  while (first != null) {
    ConditionNode next = first.nextWaiter;
    if ((firstWaiter = next) == null)
      lastWaiter = null;
    if ((first.getAndUnsetStatus(COND) & COND) != 0) {
      enqueue(first);
      if (!all)
          break;
    }
    first = next;
  }
}
```

è¿™é‡Œä¼šå°†èŠ‚ç‚¹ä»æ¡ä»¶é˜Ÿåˆ—å¤´éƒ¨ç§»å‡ºï¼Œç„¶åæ·»åŠ åˆ°ç­‰å¾…é˜Ÿåˆ—ä¸­ã€‚éœ€è¦ä¸»è¦çš„æ˜¯ `getAndUnsetStatus` è¿”å›çš„æ˜¯ä¹‹å‰çš„æ—§å€¼ï¼Œè€Œä¸æ˜¯æ–°å€¼ï¼Œæ‰€ä»¥ `first.getAndUnsetStatus(COND) & COND` æ˜¯åœ¨åˆ¤æ–­èŠ‚ç‚¹æ˜¯å¦å¤„äºç­‰å¾…çŠ¶æ€ã€‚

æœ€åçš„ `enqueue` åˆ™æ˜¯å°†èŠ‚ç‚¹æ”¾åˆ°ç­‰å¾…é˜Ÿåˆ—ä¸­ï¼š

```java
final void enqueue(Node node) {
  if (node != null) {
    for (;;) {
      Node t = tail;
      node.setPrevRelaxed(t);        // avoid unnecessary fence
      if (t == null)                 // initialize
        tryInitializeHead();
      else if (casTail(t, node)) {
        t.next = node;
        if (t.status < 0)          // wake up to clean link
          LockSupport.unpark(node.waiter);
        break;
      }
    }
  }
}
```

å®é™…å’Œ `acquire` æ–¹æ³•ä¸­å…¥é˜Ÿçš„ä»£ç ä¸€æ ·ï¼Œéƒ½æ˜¯ CAS `tail` æ¥æ’å…¥èŠ‚ç‚¹ã€‚åœ¨æ’å…¥å®Œæ¯•åï¼Œå°±ä¼šå”¤é†’å¯¹åº”çº¿ç¨‹ï¼Œå¯¹åº”çº¿ç¨‹å†å»æŠ¢é”ã€‚

# è§‚åæ„Ÿ

ä¸å¾—ä¸è¯´ï¼ŒJava 17 çœŸçš„æ˜¯ç‹ ç‹ é‡æ„äº†ä¸€é AQSï¼Œè¿™é‡Œçš„ä»£ç ç›¸æ¯” Java 8 å˜å¾—éå¸¸æ¸…æ™°äº†ï¼å¦‚æœä½ ä¹‹å‰çœ‹è¿‡ Java 8 çš„å®ç°ï¼Œä¼šå‘ç°é‡Œé¢éå¸¸å¤æ‚ã€‚