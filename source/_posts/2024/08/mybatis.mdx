---
title: æ²¡æœ‰äº† Spring ä½ è¿˜ä¼šç”¨ Mybatis å—? Mybatis-Spring èµ„æºç®¡ç†è¯¦è§£ã€‚
date: 2023-03-07 23:22:15
categories:
  - Javaæºç 
seo:
  description: å½“ Mybatis ç¦»å¼€äº† Springï¼Œä½ è¿˜ä¼šç”¨å—ï¼Ÿæœ¬ç¯‡å°†å¸¦ä½ äº†è§£ Mybatis-Spring åº•å±‚æºç ï¼Œå¸®åŠ©ä½ äº†è§£ Spring æ˜¯å¦‚ä½•ç®¡ç† Mybatis èµ„æºçš„ã€‚
---

> [!IMPORTANT]
> æœ¬æ–‡åŸºäº spring-jdbc-6.1.13ã€mybatis-spring-boot-starter-3.0.3
>
> æœ¬æ–‡ä¸»è¦æ˜¯ä¸€äº›æ€»ç»“æ€§çš„ç»“è®ºï¼Œä¸ä¼šå¤§é‡å±•ç¤ºæºç ï¼Œå»ºè®®è‡ªå·±æ‰“æ–­ç‚¹è¾¹è·Ÿè¾¹çœ‹æˆ–è€…åé¢å›é¡¾çš„æ—¶å€™çœ‹ã€‚

# å¼€å¤´åºŸè¯

é¦–å…ˆæ¥ä¸€ä¸ªéå¸¸ç°å®çš„é—®é¢˜ï¼Œå½“ Mybatis ç¦»å¼€äº† Springï¼Œä½ è¿˜ä¼šç”¨å—ï¼Ÿ

é¦–å…ˆæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹æ²¡æœ‰ Spring è¯¥æ€ä¹ˆç”¨ï¼š

```java
DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();
TransactionFactory transactionFactory = new JdbcTransactionFactory();
Environment environment = new Environment("development", transactionFactory, dataSource);
Configuration configuration = new Configuration(environment);
configuration.addMapper(BlogMapper.class);

SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);

try (SqlSession session = sqlSessionFactory.openSession(true)) {
    BlogMapper blogMapper = session.getMapper(BlogMapper.class);

    blogMapper.doSth();

    // ...
}
```


æœ‰æ²¡æœ‰å‘ç°è¿™é‡Œå¾ˆè¿èƒŒæˆ‘ä»¬çš„"å¸¸è¯†"ï¼Ÿåœ¨ `Spring` ä¸­ï¼Œæˆ‘ä»¬éƒ½æ˜¯ç›´æ¥æ³¨å…¥ `Mapper` ç„¶åç›´æ¥å°±å¼€å§‹ç”¨äº†ã€‚è€Œåœ¨è¿™é‡Œï¼Œæˆ‘ä»¬è¿˜éœ€è¦è‡ªå·±å¼€ `SqlSession` æ¥è·å– `Mapper`ã€‚

---

æ¥ä¸‹æ¥ï¼Œæœ¬æ–‡å°†å¸¦ä½ è¯¦ç»†äº†è§£ `Spring` æ˜¯å¦‚ä½•ç®¡ç† `Mybatis` èµ„æºçš„ã€‚




# Mybatis-Spring åŸç†

åœ¨ `Mybatis` æ–‡æ¡£çš„ [ä½œç”¨åŸŸï¼ˆScopeï¼‰å’Œç”Ÿå‘½å‘¨æœŸ](https://mybatis.net.cn/getting-started.html#a.E4.BD.9C.E7.94.A8.E5.9F.9F.EF.BC.88Scope.EF.BC.89.E5.92.8C.E7.94.9F.E5.91.BD.E5.91.A8.E6.9C.9F) ä¸­æåˆ°: `æ¯ä¸ªçº¿ç¨‹éƒ½åº”è¯¥æœ‰å®ƒè‡ªå·±çš„ SqlSession å®ä¾‹ã€‚æ¯æ¬¡æ”¶åˆ° HTTP è¯·æ±‚ï¼Œå°±å¯ä»¥æ‰“å¼€ä¸€ä¸ª SqlSessionï¼Œè¿”å›ä¸€ä¸ªå“åº”åï¼Œå°±å…³é—­å®ƒ`ã€‚

é‚£ä¹ˆ `Spring` (å®é™…æ˜¯ Mybatis-Spring)æ˜¯åœ¨å“ªé‡Œç»™ `Mapper` ç»‘å®š `SqlSession` çš„å‘¢ï¼Ÿ

![MapperProxy](https://5j9g3t.site/images/2024/10/MapperProxy2.webp)

é€šè¿‡ä¸Šå›¾å¯ä»¥å‘ç°ï¼Œ`SqlSessionTemplate` é‡Œé¢çš„ `sqlSessionProxy` åˆæ˜¯ä¸€ä¸ªä»£ç†ï¼Œå¹¶ä¸”ç”¨çš„æ˜¯è‡ªå·±çš„å†…éƒ¨ç±» `org.mybatis.spring.SqlSessionTemplate.SqlSessionInterceptor`ã€‚åœ¨è¿™ä¸ªä»£ç†ç±»ä¸­ï¼Œæˆ‘ä»¬å°±**å¯ä»¥æ‰¾åˆ°ç›¸å…³æ‡’åŠ è½½çš„ä»£ç äº†**ã€‚

åœ¨ç»§ç»­çœ‹å‰ï¼Œéœ€è¦äº†è§£ä¸€ä¸ªéå¸¸é‡è¦çš„ç±»ï¼š`TransactionSynchronizationManager`:

```java
public abstract class TransactionSynchronizationManager {

	private static final ThreadLocal<Map<Object, Object>> resources =
			new NamedThreadLocal<>("Transactional resources");

	private static final ThreadLocal<Set<TransactionSynchronization>> synchronizations =
			new NamedThreadLocal<>("Transaction synchronizations");

	private static final ThreadLocal<String> currentTransactionName =
			new NamedThreadLocal<>("Current transaction name");

	private static final ThreadLocal<Boolean> currentTransactionReadOnly =
			new NamedThreadLocal<>("Current transaction read-only status");

	private static final ThreadLocal<Integer> currentTransactionIsolationLevel =
			new NamedThreadLocal<>("Current transaction isolation level");

	private static final ThreadLocal<Boolean> actualTransactionActive =
			new NamedThreadLocal<>("Actual transaction active");

  // snip

}
```

- `resources`: ä¿å­˜å½“å‰çº¿ç¨‹çš„æ•°æ®åº“è¿æ¥ï¼Œä¾¿äºåç»­äº‹åŠ¡è·å–
- `synchronizations`: ä¿å­˜äº‹åŠ¡åŒæ­¥çš„å›è°ƒï¼Œä¾‹å¦‚ `beforeCommit`ã€`afterCompletion` ç­‰
- `currentTransactionName`ï¼šä¿å­˜äº‹åŠ¡çš„åç§°
- `currentTransactionReadOnly`ï¼šæ ‡è¯†å½“å‰äº‹åŠ¡æ˜¯å¦åªè¯»
- `currentTransactionIsolationLevel`: å½“å‰äº‹åŠ¡éš”ç¦»çº§åˆ«
- `actualTransactionActive`: å½“å‰çº¿ç¨‹æ˜¯å¦çœŸçš„å¼€å¯äº†äº‹åŠ¡

ä¾‹å¦‚è°ƒç”¨ `org.springframework.transaction.support.TransactionSynchronizationManager#isActualTransactionActive` å°±å¯ä»¥åˆ¤æ–­å½“å‰çº¿ç¨‹æ˜¯å¦å¼€å¯äº†äº‹åŠ¡ã€‚

# SqlSession çš„åˆ›å»ºä¸ ThreadLocal çš„ç»‘å®š

åœ¨ç¬¬ä¸€æ¬¡å°è¯•è·å– `SqlSession` æ—¶ï¼Œå°±ä¼šå°è¯•ç»‘å®šç›¸å…³çš„ `ThreadLocal`ã€‚

`org.mybatis.spring.SqlSessionTemplate.SqlSessionInterceptor#invoke` -> `org.mybatis.spring.SqlSessionUtils#getSqlSession` -> `org.mybatis.spring.SqlSessionUtils#registerSessionHolder`(éƒ¨åˆ†æ— å…³ç´§è¦çš„ä»£ç è¢«çœç•¥):

```java
private static void registerSessionHolder(SqlSessionFactory sessionFactory, ExecutorType executorType,
      PersistenceExceptionTranslator exceptionTranslator, SqlSession session) {
  SqlSessionHolder holder;
  // åˆ¤æ–­æ˜¯å¦éœ€è¦å¼€å¯äº‹åŠ¡.
  if (TransactionSynchronizationManager.isSynchronizationActive()) {
    Environment environment = sessionFactory.getConfiguration().getEnvironment();

    if (environment.getTransactionFactory() instanceof SpringManagedTransactionFactory) {
      LOGGER.debug(() -> "Registering transaction synchronization for SqlSession [" + session + "]");

      holder = new SqlSessionHolder(session, executorType, exceptionTranslator);
      // ç»‘å®š resources åˆ° ThreadLocal
      TransactionSynchronizationManager.bindResource(sessionFactory, holder);
      // ç»‘å®š synchronizations
      TransactionSynchronizationManager
          .registerSynchronization(new SqlSessionSynchronization(holder, sessionFactory));
      // æ ‡è¯†å½“å‰äº‹åŠ¡å·²ç»ç»‘å®šäº† synchronizations
      holder.setSynchronizedWithTransaction(true);
      // å¼•ç”¨è®¡æ•°åŠ ä¸€
      holder.requested();
    } else {

      // åˆ¤æ–­å½“å‰æ˜¯ä¸æ˜¯ä½¿ç”¨ SpringManagedTransactionFactory æ¥ç®¡ç†äº‹åŠ¡ï¼Œå¦‚æœä¸æ˜¯åˆ™ç›´æ¥æŠ¥é”™

    }
  } else {
    // å•¥éƒ½ä¸åš
  }

}
```

è‡³æ­¤ï¼Œäº‹åŠ¡å°±æˆåŠŸå¼€å¯äº†ã€‚åé¢çš„ `Mapper` æƒ³è¦è·å– `SqlSession` å°±å¯ä»¥ç›´æ¥å¤ç”¨äº†:

```java
// org.mybatis.spring.SqlSessionUtils#getSqlSession
public static SqlSession getSqlSession(SqlSessionFactory sessionFactory, ExecutorType executorType,
    PersistenceExceptionTranslator exceptionTranslator) {

  notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED);
  notNull(executorType, NO_EXECUTOR_TYPE_SPECIFIED);

  // è·å–ç»‘å®šçš„èµ„æº
  SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);
  // è·å–å¯¹åº”çš„ SqlSessionï¼Œå¹¶å°†å¼•ç”¨è®¡æ•°åŠ ä¸€
  SqlSession session = sessionHolder(executorType, holder);
  if (session != null) {
    return session;
  }

  // çº¿ç¨‹è¿˜æ²¡æœ‰ç»‘å®šï¼Œåˆ›å»ºæ–°çš„å¹¶åˆ¤æ–­æ˜¯å¦éœ€è¦ç»‘å®šï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬ä¸Šé¢çœ‹åˆ°çš„ä»£ç 
  LOGGER.debug(() -> "Creating a new SqlSession");
  session = sessionFactory.openSession(executorType);

  registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session);

  return session;
}
```

# SqlSession çš„é‡Šæ”¾

åœ¨è‡ªåŠ¨æäº¤çš„æƒ…å†µä¸‹ï¼Œ`SqlSession` ç”¨å®Œå°±ä¼šè¢«é‡Šæ”¾ï¼Œåœ¨ `org.mybatis.spring.SqlSessionTemplate.SqlSessionInterceptor#invoke` ä¸­çš„ `finally` ä»£ç å—å°±å¯ä»¥çœ‹åˆ°ï¼Œæœ€åè°ƒç”¨äº† `org.mybatis.spring.SqlSessionUtils#closeSqlSession` æ¥é‡Šæ”¾ `SqlSession`:

```java
public static void closeSqlSession(SqlSession session, SqlSessionFactory sessionFactory) {
  notNull(session, NO_SQL_SESSION_SPECIFIED);
  notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED);

  SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);
  if ((holder != null) && (holder.getSqlSession() == session)) {
    LOGGER.debug(() -> "Releasing transactional SqlSession [" + session + "]");
    // å¼•ç”¨è®¡æ•°å‡ä¸€
    holder.released();
  } else {
    LOGGER.debug(() -> "Closing non transactional SqlSession [" + session + "]");
    // è‡ªåŠ¨æäº¤ï¼Œç›´æ¥å…³é—­
    session.close();
  }
}
```

å¯ä»¥å‘ç°åœ¨å¼€å¯äº‹åŠ¡çš„æƒ…å†µä¸‹ï¼Œè¿™é‡Œä»…ä»…æ˜¯å°†å¼•ç”¨è®¡æ•°å‡ä¸€ï¼Œé‚£ä¹ˆçœŸæ­£çš„å…³é—­åœ¨å“ªå‘¢ï¼Ÿ

å…¶å®ä¹Ÿä¸éš¾çŒœåˆ°ï¼Œæˆ‘ä»¬åœ¨å“ªä¸ªæ–¹æ³•ä¸Šçš„ `@Transactional`ï¼Œè¿™ä¸ªæ–¹æ³•ç»“æŸåè‚¯å®šå°±ä¼šå»å…³é—­ `SqlSession`ã€‚è¿™é‡Œæ˜¯é€šè¿‡åŠ¨æ€ä»£ç†å®ç°çš„ï¼Œå…·ä½“çš„ç±»ä¸ºï¼š`org.springframework.transaction.interceptor.TransactionAspectSupport`ï¼Œç›´æ¥ä» `invokeWithinTransaction` å¼€å§‹çœ‹å°±å¯ä»¥äº†ã€‚

å¯ä»¥åœ¨é‡Œé¢æ‰¾åˆ° `commitTransactionAfterReturning` è¿™ä¸ªæ–¹æ³•ï¼Œå¾ˆæ˜¾ç„¶ï¼Œè¿™ä¸ªæ–¹æ³•å°±æ˜¯ç”¨æ¥æäº¤å¹¶å…³é—­è¿æ¥çš„:

```java
protected void commitTransactionAfterReturning(@Nullable TransactionInfo txInfo) {
  if (txInfo != null && txInfo.getTransactionStatus() != null) {
    if (logger.isTraceEnabled()) {
      logger.trace("Completing transaction for [" + txInfo.getJoinpointIdentification() + "]");
    }
    txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());
  }
}
```

å¯ä»¥å‘ç°ï¼Œå¦‚æœæ²¡æœ‰å¼€å¯äº‹åŠ¡ï¼Œåˆ™ä¸ä¼šåšä»»ä½•äº‹ã€‚å¦åˆ™å°†ä¼šè·å– `TransactionManager` ç„¶åè°ƒç”¨ `commit` æ–¹æ³•ã€‚

ç‚¹è¿›å»ç»§ç»­è¿½ `org.springframework.transaction.support.AbstractPlatformTransactionManager#commit` -> `org.springframework.transaction.support.AbstractPlatformTransactionManager#processCommit`(è¿™é‡Œæ–¹æ³•å¾ˆé•¿ï¼Œåªä¿ç•™éƒ¨åˆ†ä»£ç ):

```java
private void processCommit(DefaultTransactionStatus status) throws TransactionException {
  try {
    boolean beforeCompletionInvoked = false;
    boolean commitListenerInvoked = false;

    try {
      boolean unexpectedRollback = false;
      prepareForCommit(status);
      triggerBeforeCommit(status);
      triggerBeforeCompletion(status);
      beforeCompletionInvoked = true;

      if (status.hasSavepoint()) {
        // snip
      }
      else if (status.isNewTransaction()) {
        if (status.isDebug()) {
          logger.debug("Initiating transaction commit");
        }
        unexpectedRollback = status.isGlobalRollbackOnly();
        this.transactionExecutionListeners.forEach(listener -> listener.beforeCommit(status));
        commitListenerInvoked = true;
        doCommit(status);
      }
      else if (isFailEarlyOnGlobalRollbackOnly()) {
        unexpectedRollback = status.isGlobalRollbackOnly();
      }

      // Throw UnexpectedRollbackException if we have a global rollback-only
      // marker but still didn't get a corresponding exception from commit.
      if (unexpectedRollback) {
        throw new UnexpectedRollbackException(
            "Transaction silently rolled back because it has been marked as rollback-only");
      }
    }
    catch (UnexpectedRollbackException ex) {
      // snip
    }
    catch (TransactionException ex) {
      // snip
    }
    catch (RuntimeException | Error ex) {
      // snip
    }

    // Trigger afterCommit callbacks, with an exception thrown there
    // propagated to callers but the transaction still considered as committed.
    try {
      triggerAfterCommit(status);
    }
    finally {
      triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);
      if (commitListenerInvoked) {
        this.transactionExecutionListeners.forEach(listener -> listener.afterCommit(status, null));
      }
    }

  }
  finally {
    cleanupAfterCompletion(status);
  }
}
```

æ­£å¸¸æƒ…å†µä¸‹(æ²¡æœ‰å¼‚å¸¸ã€äº‹åŠ¡æ­£å¸¸æäº¤)ï¼Œä¸»è¦æ˜¯è¿™æ ·çš„æµç¨‹(`TransactionManager` çš„å®ç°ç±»é»˜è®¤æ˜¯ `JdbcTransactionManager`)ï¼š

1. `prepareForCommit`: åœ¨æäº¤å‰è¿›è¡Œä¸€äº›å‡†å¤‡å·¥ä½œã€‚
2. `triggerBeforeCommit`: è°ƒç”¨åŒæ­¥å™¨(`TransactionSynchronization`)çš„ `beforeCommit` æ–¹æ³•
3. `triggerBeforeCompletion`: è°ƒç”¨åŒæ­¥å™¨(`TransactionSynchronization`)çš„ `beforeCompletion` æ–¹æ³•
4. `doCommit`: è·å–åˆ° `Connection` å¹¶æäº¤
5. `triggerAfterCommit`: è°ƒç”¨åŒæ­¥å™¨(`TransactionSynchronization`)çš„ `afterCommit` æ–¹æ³•
6. `triggerAfterCompletion`: è°ƒç”¨åŒæ­¥å™¨(`TransactionSynchronization`)çš„ `afterCompletion` æ–¹æ³•
7. `cleanupAfterCompletion`: æ¸…é™¤ç»‘å®šçš„ `ThreadLocal`ï¼Œæ¢å¤ `Connection` çš„çŠ¶æ€ç­‰(è®¾ç½®è‡ªåŠ¨æäº¤ã€éš”ç¦»çº§åˆ«ç­‰)ï¼Œå¦‚æœæœ‰è¢«æŒ‚èµ·çš„äº‹åŠ¡ï¼Œåˆ™æ¢å¤å¯¹åº”çš„äº‹åŠ¡ã€‚

## äº‹åŠ¡æäº¤äº†ä¸¤æ¬¡?

åœ¨ä¹‹å‰æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œé»˜è®¤çš„åŒæ­¥å™¨æ˜¯ `SqlSessionSynchronization`ã€‚è€Œåœ¨ `org.mybatis.spring.SqlSessionUtils.SqlSessionSynchronization#beforeCommit` ä¸­æˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œè¿™é‡Œåˆè°ƒç”¨äº† `SqlSession` çš„ `commit` æ–¹æ³•ï¼Œæ‰€ä»¥è¿™ä¸ªäº‹åŠ¡ä¸€å…±æäº¤äº†ä¸¤æ¬¡ !?

![beforeCommit](https://5j9g3t.site/images/2024/10/beforeCommit.webp)

æ²¡é”™ï¼Œç¬¬ä¸€æ¬¡çœ‹åˆ°è¿™é‡Œæˆ‘ç¡®å®è¢«è¿·æƒ‘ä½äº†ã€‚ä½†æ˜¯å…¶å®ä¸Šé¢çš„æ³¨é‡Šå·²ç»è¯´çš„å¾ˆæ¸…æ¥šäº†ï¼Œåƒäº†ä¸æ‡‚è‹±è¯­çš„å‘ğŸ˜¢ã€‚

è¿™æ®µå¤§è‡´æ„æ€å¦‚ä¸‹ï¼š

> `Connection` çš„ *æäº¤* æˆ–è€… *å›æ»š* å°†ä¼šè¢« `ConnectionSynchronization` æˆ– `DataSourceTransactionManager` å¤„ç†ã€‚
>
> ä½†æ˜¯ï¼Œè¯·æ¸…ç† `SqlSession` / `Executor` ï¼ŒåŒ…æ‹¬ *æ‰¹å¤„ç†* æ“ä½œï¼Œä»¥ç¡®ä¿å®ƒä»¬å®é™…è¢«æ‰§è¡Œè¿‡ã€‚
>
> `SpringManagedTransaction` ä¸ä¼šçœŸçš„åœ¨ jdbc è¿æ¥çš„å±‚é¢ä¸Š *æäº¤* ã€‚


è¿˜æ˜¯ä¸å¤ªè¯—äººè¯ï¼Œç®€å•æ¥è¯´å°±æ˜¯ä½ åœ¨åŒæ­¥å™¨é‡Œåªéœ€è¦ç¡®ä¿åˆ·æ–° `SqlSession`ã€ `Executor` å’Œæ‰¹å¤„ç†æ“ä½œå°±è¡Œäº†ï¼Œæäº¤çš„äº‹æƒ…ä¸ç”¨ä½ ç®¡ã€‚

é‚£ä¹ˆå®é™…æ˜¯æ€ä¹ˆæ ·çš„å‘¢ï¼Œåœ¨ç»§ç»­å‰æˆ‘ä»¬éœ€è¦å†å›åˆ°æ²¡æœ‰ Spring çš„ mybatisã€‚

### TransactionFactory

è¿˜è®°å¾—å‰é¢æˆ‘ä»¬ä¸ä½¿ç”¨ Spring æ¥é…ç½® mybatis çš„æ—¶å€™å—ï¼Ÿæˆ‘ä»¬éœ€è¦æ‰‹åŠ¨é…ç½®ä¸€ä¸ª `TransactionFactory`ï¼Œåœ¨æ–‡æ¡£ä¸­ç›´æ¥ä½¿ç”¨äº† `JdbcTransactionFactory`ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹å®ƒçš„å®ç°ã€‚

æ—¢ç„¶æ˜¯å·¥å‚ç±»ï¼Œå°±åªéœ€è¦å…³æ³¨å®ƒè¿”å›çš„ç±»å‹äº†ï¼Œè¿™é‡Œå®ƒè¿”å›çš„æ˜¯ `JdbcTransaction`ï¼Œæˆ‘ä»¬æ¥ç€çœ‹ã€‚

è¿™é‡Œä¸»è¦å…³æ³¨å®ƒçš„ `commit` æ–¹æ³•ï¼š

```java
@Override
public void commit() throws SQLException {
  if (connection != null && !connection.getAutoCommit()) {
    if (log.isDebugEnabled()) {
      log.debug("Committing JDBC Connection [" + connection + "]");
    }
    connection.commit();
  }
}
```

å¯ä»¥å‘ç°å®ƒçš„ `commit` æ–¹æ³•æ˜¯çœŸçš„ç›´æ¥è°ƒç”¨ jdbc è¿æ¥æäº¤äº†ã€‚è¿˜è®°å¾—æˆ‘ä»¬ä¹‹å‰ç¿»è¯‘çš„å—ï¼Œåœ¨ Spring é‡Œé¢ï¼šSpringManagedTransaction` ä¸ä¼šçœŸçš„åœ¨ jdbc è¿æ¥çš„å±‚é¢ä¸Š *æäº¤* ã€‚

æˆ‘ä»¬æ¥çœ‹ Spring å®ç°é‡Œçš„ `commit`:

```java
@Override
public void commit() throws SQLException {
  if (this.connection != null && !this.isConnectionTransactional && !this.autoCommit) {
    LOGGER.debug(() -> "Committing JDBC Connection [" + this.connection + "]");
    this.connection.commit();
  }
}
```

å¯ä»¥å‘ç°å®ƒåŠ äº†ä¸€ä¸ªæœ€å…³é”®çš„åˆ¤æ–­ï¼š`!this.isConnectionTransactional`ã€‚é‚£ä¹ˆå¯ä»¥è¯´æ˜ï¼Œå¦‚æœå½“å‰å¼€å¯äº†äº‹åŠ¡ï¼Œé‚£ä¹ˆè°ƒç”¨ `SqlSession#commit` å°±ä¸ä¼šçœŸæ­£çš„æäº¤ã€‚

> [!NOTE]
> è¿™é‡Œçœç•¥äº†éƒ¨åˆ†ä¸Šä¸‹æ–‡ã€‚`SqlSession#commit` ä¼šè°ƒç”¨ `Executor#commit`(`org.apache.ibatis.executor.BaseExecutor#commit`)ï¼Œæœ€ç»ˆä¼šè°ƒç”¨ `org.apache.ibatis.transaction.Transaction#commit`


æ‰€ä»¥åœ¨è¿™é‡Œè°ƒç”¨ `SqlSession` çš„ `commit`ï¼Œåªæ˜¯ä¸ºäº†æ¸…é™¤ç¼“å­˜è€Œå·²ï¼Œå¹¶æ²¡æœ‰çœŸæ­£æäº¤çš„æ„æ€ã€‚



# äº‹åŠ¡çš„åˆ›å»º

åœ¨ Spring ä¸­å¯ä»¥è®¾ç½®äº‹åŠ¡çš„ä¼ æ’­çº§åˆ«(`TransactionDefinition`)ï¼š

- `PROPAGATION_REQUIRED`(é»˜è®¤): å¦‚æœå½“å‰å­˜åœ¨äº‹åŠ¡ï¼Œåˆ™åŠ å…¥è¯¥äº‹åŠ¡ï¼›å¦‚æœå½“å‰æ²¡æœ‰äº‹åŠ¡ï¼Œåˆ™åˆ›å»ºä¸€ä¸ªæ–°çš„äº‹åŠ¡ã€‚
- `PROPAGATION_REQUIRES_NEW`: åˆ›å»ºä¸€ä¸ªæ–°çš„äº‹åŠ¡ï¼Œå¦‚æœå½“å‰å­˜åœ¨äº‹åŠ¡ï¼Œåˆ™æŠŠå½“å‰äº‹åŠ¡æŒ‚èµ·ã€‚
- `PROPAGATION_NESTED`ï¼šåˆ›å»ºä¸€ä¸ªå­äº‹åŠ¡ï¼Œå¦‚æœå­äº‹åŠ¡å›æ»šï¼Œå¯¹åº”çš„çˆ¶äº‹åŠ¡ä¹Ÿä¼šå›æ»š(å¦‚æœæœ‰)ã€‚
- `PROPAGATION_MANDATORY`ï¼šå¦‚æœå½“å‰å­˜åœ¨äº‹åŠ¡ï¼Œåˆ™åŠ å…¥è¯¥äº‹åŠ¡ï¼›å¦‚æœå½“å‰æ²¡æœ‰äº‹åŠ¡ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸ã€‚
- `PROPAGATION_SUPPORTS`: å¦‚æœå½“å‰å­˜åœ¨äº‹åŠ¡ï¼Œåˆ™åŠ å…¥è¯¥äº‹åŠ¡ï¼›å¦‚æœå½“å‰æ²¡æœ‰äº‹åŠ¡ï¼Œåˆ™ä»¥éäº‹åŠ¡çš„æ–¹å¼ç»§ç»­è¿è¡Œã€‚
- `PROPAGATION_NOT_SUPPORTED`: ä»¥éäº‹åŠ¡æ–¹å¼è¿è¡Œï¼Œå¦‚æœå½“å‰å­˜åœ¨äº‹åŠ¡ï¼Œåˆ™æŠŠå½“å‰äº‹åŠ¡æŒ‚èµ·ã€‚
- `PROPAGATION_NEVER`: ä»¥éäº‹åŠ¡æ–¹å¼è¿è¡Œï¼Œå¦‚æœå½“å‰å­˜åœ¨äº‹åŠ¡ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸ã€‚

é‚£ä¹ˆäº‹åŠ¡åœ¨åˆ›å»ºæ—¶ï¼Œæ˜¯å¦‚ä½•æ ¹æ®ä¸åŒçš„ä¼ æ’­çº§åˆ«æ¥åˆ›å»ºäº‹åŠ¡çš„å‘¢ï¼Ÿ

---

åœ¨ `org.springframework.transaction.interceptor.TransactionAspectSupport#createTransactionIfNecessary` -> `org.springframework.transaction.support.AbstractPlatformTransactionManager#getTransaction` å°±å¯ä»¥æ‰¾åˆ°ç›¸å…³å¼€å¯äº‹åŠ¡çš„ä»£ç ã€‚

è¿™é‡Œä»£ç å¾ˆé•¿ï¼Œä½†ä¸ç®¡æ€ä¹ˆæ ·ï¼Œ**æœ€ç»ˆéƒ½æ˜¯è¿”å›ä¸€ä¸ª `TransactionStatus`**ï¼Œé»˜è®¤çš„å®ç°æ˜¯ `org.springframework.transaction.support.DefaultTransactionStatus`:

```java
public class DefaultTransactionStatus extends AbstractTransactionStatus {

	@Nullable
	private final String transactionName;

	@Nullable
	private final Object transaction;

	private final boolean newTransaction;

	private final boolean newSynchronization;

	private final boolean nested;

	private final boolean readOnly;

	private final boolean debug;

	@Nullable
	private final Object suspendedResources;

  // snip

}
```

è¿™äº›å­—æ®µçš„æ„æ€åˆ†åˆ«æ˜¯ï¼š

- `transactionName`: äº‹åŠ¡çš„åç§°ï¼Œä¸€èˆ¬æ˜¯è¢«ä»£ç†çš„æ–¹æ³•å…¨é™å®šåç§°ï¼Œä¾‹å¦‚ `foo.bar.TestService.doService`ã€‚
- `transaction`: ä¿å­˜äº† `org.springframework.transaction.support.AbstractPlatformTransactionManager#doGetTransaction` çš„è¿”å›å€¼ï¼Œé»˜è®¤ç±»å‹ä¸º `org.springframework.jdbc.datasource.DataSourceTransactionManager.DataSourceTransactionObject`ã€‚
- `newTransaction`: æ˜¯ä¸æ˜¯ä¸€ä¸ªæ–°çš„äº‹åŠ¡ã€‚ä¾‹å¦‚å¤šä¸ª `Transactional` æ–¹æ³•åµŒå¥—ï¼Œç¬¬ä¸€ä¸ªå¼€å¯äº‹åŠ¡çš„æ–¹æ³•è¯¥å€¼ä¸º `true`ï¼Œå…¶å®ƒçš„å‡ä¸º `false`ã€‚
- `newSynchronization`: å½“å‰äº‹åŠ¡æ˜¯å¦åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„äº‹åŠ¡åŒæ­¥å™¨ã€‚
- `nested`: æ˜¯å¦åµŒå¥—(å­äº‹åŠ¡)ã€‚
- `readOnly`: æ˜¯å¦åªè¯»ã€‚
- `debug`: ç”¨äº debugã€‚
- `suspendedResources`: è¢«æŒ‚èµ·çš„èµ„æºï¼Œä¾‹å¦‚åœ¨ `PROPAGATION_REQUIRES_NEW` çš„ä¼ æ’­çº§åˆ«ä¸‹ï¼Œä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„äº‹åŠ¡ï¼Œæ—§çš„äº‹åŠ¡å°†ä¼šåœ¨è¿™é‡Œè¢«æŒ‚èµ·ã€‚



## transactionSynchronization

å…³äº `newSynchronization` è¿™ä¸ªå±æ€§ï¼Œä¸€å¼€å§‹å¯èƒ½è¿˜æŒºæ‡µé€¼çš„ã€‚å¦‚æœä¸æƒ³ç®¡å¤ªå¤šï¼Œåªéœ€è¦è®°ä½è¯¥å€¼ä¸º `true` æ—¶ï¼Œåé¢çš„äº‹åŠ¡è·å– `SqlSession` æ—¶æ‰ä¼šåˆ›å»ºç›¸å…³åŒæ­¥å™¨ã€‚

> [!NOTE]
> å½“è¯¥å€¼ä¸º `true` æ—¶ `org.springframework.transaction.support.AbstractPlatformTransactionManager#prepareSynchronization` å°†ä¼šç»‘å®šç›¸å…³çº¿ç¨‹å˜é‡ï¼Œåé¢çº¿ç¨‹åœ¨è·å– `SqlSession` æ—¶ï¼Œ`org.mybatis.spring.SqlSessionUtils#registerSessionHolder` ä¼šåˆ¤æ–­å½“å‰æ˜¯å¦æ¿€æ´»åŒæ­¥å™¨ï¼Œç„¶åå†å»ç»‘å®šç›¸å…³èµ„æºã€‚

é‚£ä¹ˆè¿™ä¸ªå€¼å…·ä½“æœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿè¿™é‡Œå°±ä¸å¾—ä¸å†å›åˆ°æˆ‘ä»¬å‰é¢çš„ä¼ æ’­çº§åˆ«äº†ã€‚ä¾‹å¦‚ `PROPAGATION_NOT_SUPPORTED` çº§åˆ«ï¼Œå®ƒä¼šæŒ‚èµ·å·²æœ‰çš„äº‹åŠ¡ï¼Œå¹¶ä¸”ä»¥éäº‹åŠ¡çš„çŠ¶æ€ç»§ç»­æ‰§è¡Œï¼Œæ‰€ä»¥è¿™é‡Œå¾ˆæ˜æ˜¾å°±ä¸éœ€è¦ç»‘å®šåŒæ­¥å™¨ã€‚

<div className="text-error">ä½†æ˜¯ï¼Œå®é™…ä¸Š Spring é»˜è®¤ä¼šç»™æ‰€æœ‰ç±»å‹çš„ä¼ æ’­çº§åˆ«åˆ›å»ºåŒæ­¥å™¨ã€‚</div>

`newSynchronization` çš„å€¼ç”± `org.springframework.transaction.support.AbstractPlatformTransactionManager#transactionSynchronization` çš„å€¼å†³å®šï¼Œè€Œè¿™ä¸ªå€¼é»˜è®¤ä¸º `SYNCHRONIZATION_ALWAYS`ã€‚ä¹Ÿå°±æ˜¯æ°¸è¿œéƒ½ä¼šåˆ›å»ºåŒæ­¥å™¨ï¼Œå³ä½¿æ²¡æœ‰å¼€å¯äº‹åŠ¡ã€‚

ä¸€å…±æœ‰ä¸‰ä¸ªå¯ç”¨çš„å€¼ï¼š

- `SYNCHRONIZATION_ALWAYS`(é»˜è®¤): æ°¸è¿œåˆ›å»ºåŒæ­¥å™¨ï¼Œå³ä½¿æ²¡æœ‰äº‹åŠ¡ã€‚
- `SYNCHRONIZATION_ON_ACTUAL_TRANSACTION`ï¼šä»…åœ¨æœ‰äº‹åŠ¡çš„æƒ…å†µä¸‹åˆ›å»ºã€‚
- `SYNCHRONIZATION_NEVER`ï¼šæ°¸è¿œä¸åˆ›å»ºã€‚

# äº‹åŠ¡çš„æŒ‚èµ·

åœ¨ Spring æ˜¯å¯ä»¥åµŒå¥—äº‹åŠ¡çš„ï¼Œä¾‹å¦‚æˆ‘ä»¬ä½¿ç”¨ `REQUIRES_NEW` çš„ä¼ æ’­çº§åˆ«ï¼Œå°±èƒ½å¤Ÿåœ¨å·²æœ‰äº‹åŠ¡çš„å‰æä¸‹å¼€å¯ä¸€ä¸ªå®Œå…¨éš”ç¦»çš„æ–°äº‹åŠ¡ã€‚é‚£ä¹ˆæ—§çš„äº‹åŠ¡åœ¨è¿™é‡Œä¼šæ€ä¹ˆå¤„ç†å‘¢ï¼Ÿ

çœ¼è§çš„å¤§ä¼™å·²ç»å¯ä»¥çœ‹åˆ°äº†ï¼Œåœ¨ `org.springframework.transaction.support.AbstractPlatformTransactionManager#getTransaction` ä¸­ï¼Œæœ‰ä¸€ä¸ªåˆ¤æ–­æ˜¯å¦å·²ç»å­˜åœ¨äº‹åŠ¡çš„ä»£ç ï¼š

```java
@Override
public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition)
    throws TransactionException {

  // snip

  if (isExistingTransaction(transaction)) {
    // Existing transaction found -> check propagation behavior to find out how to behave.
    return handleExistingTransaction(def, transaction, debugEnabled);
  }

  // snip

}
```

å…·ä½“çš„ä»£ç å°±ä¸ç»†çœ‹äº†ï¼Œå¤§è‡´æµç¨‹å¦‚ä¸‹ï¼š

- è°ƒç”¨åŒæ­¥å™¨çš„ `suspend` æ–¹æ³•(`org.springframework.transaction.support.AbstractPlatformTransactionManager#suspend`)ã€‚
- æ¸…é™¤æ—§äº‹åŠ¡ç»‘å®šçš„ç›¸å…³çº¿ç¨‹å˜é‡(`org.springframework.transaction.support.AbstractPlatformTransactionManager#suspend`)ã€‚
- æ ¹æ®ä¼ æ’­çº§åˆ«åˆ›å»º `TransactionStatus`ï¼Œå¹¶å°† `suspendedResources` è®¾ç½®ä¸ºä¸Šä¸ªäº‹åŠ¡(`org.springframework.transaction.support.AbstractPlatformTransactionManager#startTransaction`)ã€‚

> [!IMPORTANT]
> TODO: å¾…å¡«å‘
>
> - æŒ‚èµ·çš„èµ„æºæ¢å¤
> - ä¸ä½¿ç”¨ Spring è‡ªå·±å°è£… Mybatis